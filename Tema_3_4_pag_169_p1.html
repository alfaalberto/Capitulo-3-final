
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Presentation</title>
        <style>
          body { 
            margin: 0; 
            font-family: sans-serif; 
            background-color: #0F172A;
            overflow: hidden; /* Important for slideshow behavior */
          }
          .presentation-export-container { 
            position: relative; 
            width: 100vw; 
            height: 100vh; 
          }
          .presentation-slide {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease-in-out; /* Smoother transition */
            box-sizing: border-box;
          }
          .presentation-slide.active {
            opacity: 1;
            visibility: visible;
            z-index: 1;
          }
          /* .slide class is generated by generateSlideHTML, ensure it fills its parent */
          .presentation-slide > .slide { 
             width: 100%; 
             height: 100%;
             box-sizing: border-box;
          }
          .nav-button {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(0,0,0,0.3);
            color: white;
            border: none;
            padding: 0; /* Remove padding to let SVG define size better */
            cursor: pointer;
            z-index: 10;
            border-radius: 50%;
            width: 44px; /* Slightly smaller */
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
          }
          .prev-button { left: 15px; }
          .next-button { right: 15px; }
          .nav-button:hover { background-color: rgba(0,0,0,0.5); }
          .nav-button:disabled { display: none !important; } /* Hide disabled buttons */
          .nav-button svg { width: 24px; height: 24px; }
        </style>
      </head>
      <body>
        <div class="presentation-export-container">
          
            <div class="presentation-slide active" id="export-slide-mb0zziv4he0mc">
                <section class="slide" style="background: linear-gradient(to bottom right, #3B82F6, #1E40AF); color: #FFFFFF; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; box-sizing: border-box; padding: 0;">
                        <iframe srcdoc="<!DOCTYPE html>
<html lang=&quot;es&quot;>
<head>
    <meta charset=&quot;UTF-8&quot;>
    <meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;>
    <title>Filtrado Paso Bajo con Kernels Gaussianos</title>
    <link href=&quot;https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css&quot; rel=&quot;stylesheet&quot;>
    <link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css&quot;>
    <script src=&quot;https://cdn.jsdelivr.net/npm/chart.js&quot;></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f4f8;
            font-family: 'Arial', sans-serif;
        }
        .slide {
            width: 1280px;
            min-height: 720px;
            background: linear-gradient(135deg, #ffffff 0%, #f0f4f8 100%);
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        .gaussian-curve {
            position: absolute;
            right: -100px;
            bottom: -50px;
            opacity: 0.2;
            transform: rotate(-10deg);
            z-index: 1;
        }
        .title {
            font-weight: 700;
            background: linear-gradient(90deg, #2c5282, #3182ce);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .comparison-container {
            background: rgba(255,255,255,0.7);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        .kernel-visual {
            position: relative;
            height: 90px;
            overflow: hidden;
            border-radius: 4px;
        }
        .feature-card {
            transition: all 0.3s ease;
        }
        .feature-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.12);
        }
        .highlight {
            color: #3182ce;
            font-weight: 600;
        }
        .intro-box {
            background: rgba(235, 244, 255, 0.8);
            border-radius: 8px;
            border-left: 4px solid #3182ce;
        }
        .pulse-animation {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.03); }
            100% { transform: scale(1); }
        }
        .tag {
            display: inline-block;
            background-color: #e6f2ff;
            color: #3182ce;
            padding: 0.2rem 0.6rem;
            border-radius: 999px;
            font-size: 0.8rem;
            margin-right: 0.5rem;
        }
    </style>
</head>
<body>
    <div class=&quot;slide flex flex-col p-12&quot;>
        <div class=&quot;flex-1 flex flex-col items-center justify-center relative z-10&quot;>
            <h1 class=&quot;title text-6xl mb-5 text-center&quot;>Filtrado Paso Bajo con Kernels Gaussianos</h1>
            
            <div class=&quot;w-24 h-1 bg-blue-600 rounded-full mb-6&quot;></div>
            
            <!-- Introducción al filtrado paso bajo -->
            <div class=&quot;intro-box p-4 mb-6 w-full max-w-4xl&quot;>
                <div class=&quot;flex items-start&quot;>
                    <div class=&quot;text-3xl text-blue-600 mr-4&quot;>
                        <i class=&quot;fas fa-info-circle&quot;></i>
                    </div>
                    <div>
                        <h3 class=&quot;font-bold text-blue-800 mb-2&quot;>¿Qué es el filtrado paso bajo?</h3>
                        <p class=&quot;text-gray-700&quot;>
                            Técnica de procesamiento de imágenes que <span class=&quot;highlight&quot;>atenúa componentes de alta frecuencia</span> (bordes, detalles finos, ruido) 
                            manteniendo la información de baja frecuencia para lograr un <span class=&quot;highlight&quot;>suavizado</span> de la imagen.
                        </p>
                        <div class=&quot;mt-2&quot;>
                            <span class=&quot;tag&quot;>Reduce ruido</span>
                            <span class=&quot;tag&quot;>Suaviza bordes</span>
                            <span class=&quot;tag&quot;>Elimina detalles finos</span>
                            <span class=&quot;tag&quot;>Prepara para segmentación</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <h2 class=&quot;text-2xl text-gray-700 text-center mb-6 max-w-4xl&quot;>
                Análisis comparativo entre <span class=&quot;highlight&quot;>Kernels Gaussianos</span> y <span class=&quot;highlight&quot;>Kernels de Caja</span>: 
                comportamiento, eficiencia y calidad de resultados en el suavizado de imágenes
            </h2>
            
            <!-- Visual comparison between kernels -->
            <div class=&quot;comparison-container w-full max-w-4xl p-4 mb-8 flex items-center justify-center pulse-animation&quot;>
                <div class=&quot;flex w-full justify-around&quot;>
                    <div class=&quot;text-center w-2/5&quot;>
                        <h3 class=&quot;font-semibold text-lg mb-2 text-blue-700&quot;>Kernel Gaussiano</h3>
                        <div class=&quot;kernel-visual mx-auto&quot;>
                            <canvas id=&quot;gaussianKernelViz&quot; width=&quot;220&quot; height=&quot;90&quot;></canvas>
                        </div>
                        <p class=&quot;text-sm mt-1 text-gray-600&quot;>Suavizado natural, transiciones continuas</p>
                    </div>
                    
                    <div class=&quot;flex items-center&quot;>
                        <div class=&quot;text-2xl text-blue-800&quot;>vs</div>
                    </div>
                    
                    <div class=&quot;text-center w-2/5&quot;>
                        <h3 class=&quot;font-semibold text-lg mb-2 text-red-700&quot;>Kernel de Caja</h3>
                        <div class=&quot;kernel-visual mx-auto&quot;>
                            <canvas id=&quot;boxKernelViz&quot; width=&quot;220&quot; height=&quot;90&quot;></canvas>
                        </div>
                        <p class=&quot;text-sm mt-1 text-gray-600&quot;>Pesos uniformes, posibles artefactos</p>
                    </div>
                </div>
            </div>
            
            <div class=&quot;grid grid-cols-3 gap-6 w-full max-w-5xl&quot;>
                <div class=&quot;bg-white p-6 rounded-lg shadow-md flex flex-col items-center feature-card&quot;>
                    <div class=&quot;text-4xl text-blue-500 mb-3&quot;>
                        <i class=&quot;fas fa-filter&quot;></i>
                    </div>
                    <h3 class=&quot;font-semibold text-xl mb-2&quot;>Fundamentos</h3>
                    <p class=&quot;text-gray-600 text-center text-sm&quot;>
                        Formulación matemática, propiedades y parámetros críticos: tamaño y desviación estándar (σ)
                    </p>
                </div>
                
                <div class=&quot;bg-white p-6 rounded-lg shadow-md flex flex-col items-center feature-card&quot;>
                    <div class=&quot;text-4xl text-blue-500 mb-3&quot;>
                        <i class=&quot;fas fa-chart-line&quot;></i>
                    </div>
                    <h3 class=&quot;font-semibold text-xl mb-2&quot;>Comparaciones</h3>
                    <p class=&quot;text-gray-600 text-center text-sm&quot;>
                        Evaluación de rendimiento, efectos visuales y comportamiento en los bordes de imagen
                    </p>
                </div>
                
                <div class=&quot;bg-white p-6 rounded-lg shadow-md flex flex-col items-center feature-card&quot;>
                    <div class=&quot;text-4xl text-blue-500 mb-3&quot;>
                        <i class=&quot;fas fa-laptop-code&quot;></i>
                    </div>
                    <h3 class=&quot;font-semibold text-xl mb-2&quot;>Aplicaciones</h3>
                    <p class=&quot;text-gray-600 text-center text-sm&quot;>
                        Casos prácticos: corrección de sombreado, extracción de regiones y tratamiento de padding
                    </p>
                </div>
            </div>
        </div>
        
        <div class=&quot;gaussian-curve&quot;>
            <canvas id=&quot;gaussianCanvas&quot; width=&quot;600&quot; height=&quot;400&quot;></canvas>
        </div>
        
        <div class=&quot;mt-8 mb-2 text-sm text-gray-500 text-center flex justify-center items-center&quot;>
            <i class=&quot;fas fa-university mr-2&quot;></i>
            <p>Procesamiento Digital de Imágenes</p>
        </div>
    </div>

    <script>
        window.onload = function() {
            // Background Gaussian curve
            const ctx = document.getElementById('gaussianCanvas').getContext('2d');
            
            // Draw Gaussian curve
            ctx.beginPath();
            ctx.moveTo(0, 400);
            
            for(let x = 0; x <= 600; x++) {
                // Gaussian function parameters
                const mean = 300;
                const sigma = 80;
                const height = 350;
                
                // Gaussian function
                const y = 400 - height * Math.exp(-Math.pow(x - mean, 2) / (2 * Math.pow(sigma, 2)));
                ctx.lineTo(x, y);
            }
            
            ctx.lineTo(600, 400);
            ctx.closePath();
            
            // Fill with gradient
            const gradient = ctx.createLinearGradient(0, 0, 600, 0);
            gradient.addColorStop(0, 'rgba(49, 130, 206, 0.1)');
            gradient.addColorStop(0.5, 'rgba(49, 130, 206, 0.3)');
            gradient.addColorStop(1, 'rgba(49, 130, 206, 0.1)');
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Stroke
            ctx.strokeStyle = 'rgba(49, 130, 206, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Gaussian Kernel Visualization
            const gaussCtx = document.getElementById('gaussianKernelViz').getContext('2d');
            gaussCtx.fillStyle = '#f0f4f8';
            gaussCtx.fillRect(0, 0, 220, 90);
            
            // Create 3D-like Gaussian kernel visualization
            const centerX = 220 / 2;
            const centerY = 90 / 2;
            const maxRadius = 40;
            
            // Draw concentric circles with gradient
            for(let r = maxRadius; r > 0; r -= 2) {
                const opacity = 1 - (r / maxRadius);
                gaussCtx.beginPath();
                gaussCtx.arc(centerX, centerY, r, 0, Math.PI * 2);
                gaussCtx.fillStyle = `rgba(49, 130, 206, ${opacity * 0.8})`;
                gaussCtx.fill();
            }
            
            // Add Gaussian curve profile
            gaussCtx.beginPath();
            gaussCtx.moveTo(20, 80);
            
            for(let x = 0; x <= 180; x++) {
                const normalizedX = x / 180;
                const y = 80 - 60 * Math.exp(-Math.pow((normalizedX - 0.5) * 4, 2));
                gaussCtx.lineTo(20 + x, y);
            }
            
            gaussCtx.strokeStyle = 'rgba(37, 99, 235, 0.8)';
            gaussCtx.lineWidth = 2;
            gaussCtx.stroke();
            
            // Box Kernel Visualization
            const boxCtx = document.getElementById('boxKernelViz').getContext('2d');
            boxCtx.fillStyle = '#f0f4f8';
            boxCtx.fillRect(0, 0, 220, 90);
            
            // Draw box kernel
            const boxWidth = 60;
            const boxHeight = 60;
            boxCtx.fillStyle = 'rgba(220, 38, 38, 0.6)';
            boxCtx.fillRect(centerX - boxWidth/2, centerY - boxHeight/2, boxWidth, boxHeight);
            boxCtx.strokeStyle = 'rgba(185, 28, 28, 0.8)';
            boxCtx.lineWidth = 2;
            boxCtx.strokeRect(centerX - boxWidth/2, centerY - boxHeight/2, boxWidth, boxHeight);
            
            // Add Box kernel profile
            boxCtx.beginPath();
            boxCtx.moveTo(20, 80);
            boxCtx.lineTo(70, 80);
            boxCtx.lineTo(70, 20);
            boxCtx.lineTo(150, 20);
            boxCtx.lineTo(150, 80);
            boxCtx.lineTo(200, 80);
            
            boxCtx.strokeStyle = 'rgba(185, 28, 28, 0.8)';
            boxCtx.lineWidth = 2;
            boxCtx.stroke();
        };
    </script>
</body>
</html>" style="width:100%; height:100%; border:none;" sandbox="allow-scripts allow-same-origin allow-popups allow-forms allow-presentation"></iframe>
                    </section>
            </div>

            <div class="presentation-slide " id="export-slide-mb13udf2imzut">
                <section class="slide" style="background: linear-gradient(to bottom right, #3B82F6, #1E40AF); color: #FFFFFF; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; box-sizing: border-box; padding: 0;">
                        <iframe srcdoc="<!DOCTYPE html>
<html lang=&quot;es&quot;>
<head>
    <meta charset=&quot;UTF-8&quot;>
    <meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;>
    <title>Fundamentos de Filtrado con Kernels Gaussianos</title>
    <link href=&quot;https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css&quot; rel=&quot;stylesheet&quot;>
    <link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css&quot;>
    <script src=&quot;https://cdn.jsdelivr.net/npm/chart.js&quot;></script>
    <script src=&quot;https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js&quot;></script>
    <link href=&quot;https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css&quot; rel=&quot;stylesheet&quot;>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f4f8;
            font-family: 'Arial', sans-serif;
        }
        .slide {
            width: 1280px; /* Fixed width for slide-like appearance */
            min-height: 720px; /* Fixed min-height */
            margin: 20px auto; /* Center the slide */
            background: linear-gradient(135deg, #ffffff 0%, #f0f4f8 100%);
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        .title {
            font-weight: 700;
            color: #2c5282;
            background: linear-gradient(90deg, #2c5282, #3182ce);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .kernel-visual {
            height: 200px;
            position: relative;
        }
        .formula-container {
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .comparison-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .gaussian-pulse {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
            100% { transform: scale(1); opacity: 1; }
        }
        .formula-highlight {
            background-color: #ebf4ff;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-weight: 600;
            color: #2c5282;
        }
        .callout {
            border-left: 4px solid #3182ce;
            padding-left: 1rem;
            background-color: #ebf8ff;
            border-radius: 0 4px 4px 0;
        }
        .image-example {
            position: relative;
            overflow: hidden;
            border-radius: 4px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
        .image-label {
            position: absolute;
            bottom: 0;
            left: 0;
            background-color: rgba(44, 82, 130, 0.8);
            color: white;
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0 4px 0 0;
        }
        .kernel-3d {
            position: relative;
            perspective: 1000px;
        }
        .kernel-3d-surface {
            transform-style: preserve-3d;
            animation: rotate3d 20s infinite linear;
        }
        @keyframes rotate3d {
            0% { transform: rotateY(0deg); }
            100% { transform: rotateY(360deg); }
        }
        /* Ensure canvas elements are responsive within their containers if needed */
        canvas {
            max-width: 100%;
            height: auto;
            display: block; /* Prevents bottom margin issues */
        }
    </style>
</head>
<body>
    <div class=&quot;slide flex flex-col p-10&quot;>
        <h1 class=&quot;title text-5xl mb-5 text-center&quot;>Fundamentos del Filtrado con Kernels Gaussianos</h1>
        <div class=&quot;w-24 h-1 bg-blue-600 rounded-full mb-6 mx-auto&quot;></div>
        
        <div class=&quot;grid grid-cols-1 md:grid-cols-2 gap-8 flex-1&quot;>
            
            <div class=&quot;flex flex-col space-y-5&quot;>
                <div class=&quot;bg-white p-5 rounded-lg shadow-md&quot;>
                    <h2 class=&quot;text-2xl text-blue-700 mb-3&quot;>Características Clave</h2>
                    <ul class=&quot;space-y-3 text-gray-700&quot;>
                        <li class=&quot;flex items-start&quot;>
                            <span class=&quot;text-blue-500 mr-2&quot;><i class=&quot;fas fa-check-circle mt-1&quot;></i></span>
                            <span><b>Distribución Normal</b>: Pesos que decrecen con la distancia al centro</span>
                        </li>
                        <li class=&quot;flex items-start&quot;>
                            <span class=&quot;text-blue-500 mr-2&quot;><i class=&quot;fas fa-check-circle mt-1&quot;></i></span>
                            <span><b>Suavizado Natural</b>: Transiciones más suaves en los bordes</span>
                        </li>
                        <li class=&quot;flex items-start&quot;>
                            <span class=&quot;text-blue-500 mr-2&quot;><i class=&quot;fas fa-check-circle mt-1&quot;></i></span>
                            <span><b>Parametrización</b>: Controlado por tamaño y σ (desviación estándar)</span>
                        </li>
                        <li class=&quot;flex items-start&quot;>
                            <span class=&quot;text-blue-500 mr-2&quot;><i class=&quot;fas fa-check-circle mt-1&quot;></i></span>
                            <span><b>Separable</b>: Puede descomponerse en dos filtrados 1D</span>
                        </li>
                    </ul>
                </div>
                
                <div class=&quot;formula-container&quot;>
                    <h2 class=&quot;text-xl text-blue-700 mb-2&quot;>Definición Matemática</h2>
                    <div class=&quot;bg-gray-50 p-3 rounded text-center&quot;>
                        <p class=&quot;mb-2 text-sm&quot;>Kernel Gaussiano 2D:</p>
                        <img src=&quot;https://chart.googleapis.com/chart?cht=tx&chl=G(x,y)=\frac{1}{2\pi\sigma^2}e^{-\frac{x^2%2By^2}{2\sigma^2}}&quot; alt=&quot;Gaussian Kernel Formula&quot; class=&quot;mx-auto&quot;>
                        
                        <div class=&quot;mt-3 grid grid-cols-2 gap-2&quot;>
                            <div>
                                <p class=&quot;text-sm mb-1&quot;>Kernel Gaussiano 1D:</p>
                                <img src=&quot;https://chart.googleapis.com/chart?cht=tx&chl=G(x)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{x^2}{2\sigma^2}}&quot; alt=&quot;1D Gaussian&quot; class=&quot;mx-auto&quot;>
                            </div>
                            <div>
                                <p class=&quot;text-sm mb-1&quot;>Propiedad de separabilidad:</p>
                                <img src=&quot;https://chart.googleapis.com/chart?cht=tx&chl=G(x,y)=G(x) \cdot G(y)&quot; alt=&quot;Separability&quot; class=&quot;mx-auto&quot;>
                            </div>
                        </div>
                    </div>
                    <div class=&quot;mt-3 text-sm text-gray-600 flex flex-col sm:flex-row justify-between&quot;>
                        <div class=&quot;mb-2 sm:mb-0&quot;>
                            <p class=&quot;font-semibold&quot;>Donde:</p>
                            <ul class=&quot;pl-5 space-y-1&quot;>
                                <li>σ = desviación estándar</li>
                                <li>x,y = coordenadas desde centro</li>
                            </ul>
                        </div>
                        <div class=&quot;callout pr-3&quot;>
                            <p class=&quot;text-sm&quot;>Tamaño mínimo del kernel:</p>
                            <p class=&quot;formula-highlight&quot;>N = 2⌈3σ⌉ + 1</p>
                            <p class=&quot;text-xs&quot;>Para capturar >99% de la distribución</p>
                        </div>
                    </div>
                </div>
                
                <div class=&quot;bg-white p-3 rounded-lg shadow-md&quot;>
                    <h2 class=&quot;text-xl text-blue-700 mb-2&quot;>Aplicación en Convolución</h2>
                    <div class=&quot;grid grid-cols-2 gap-2&quot;>
                        <div class=&quot;image-example h-32&quot;>
                            <canvas id=&quot;originalImageSmall&quot; width=&quot;200&quot; height=&quot;130&quot; class=&quot;w-full h-full object-cover&quot;></canvas>
                            <div class=&quot;image-label&quot;>Original</div>
                        </div>
                        <div class=&quot;image-example h-32&quot;>
                            <canvas id=&quot;gaussBlurImageSmall&quot; width=&quot;200&quot; height=&quot;130&quot; class=&quot;w-full h-full object-cover&quot;></canvas>
                            <div class=&quot;image-label&quot;>Filtrado Gaussiano (σ≈ej. 3px blur)</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class=&quot;flex flex-col space-y-5&quot;>
                <div class=&quot;comparison-container p-5&quot;>
                    <h2 class=&quot;text-xl text-blue-700 mb-3&quot;>Comparación Visual: Gaussiano vs Caja</h2>
                    
                    <div class=&quot;flex flex-col sm:flex-row justify-between&quot;>
                        <div class=&quot;text-center w-full sm:w-5/12 mb-4 sm:mb-0&quot;>
                            <div class=&quot;kernel-visual&quot;>
                                <h3 class=&quot;font-semibold mb-2&quot;>Kernel de Caja</h3>
                                <canvas id=&quot;boxKernelCanvas&quot; width=&quot;220&quot; height=&quot;160&quot; class=&quot;mx-auto&quot;></canvas>
                                <p class=&quot;text-sm mt-1 text-gray-600&quot;>Pesos uniformes</p>
                            </div>
                        </div>
                        
                        <div class=&quot;text-center w-full sm:w-5/12&quot;>
                            <div class=&quot;kernel-visual gaussian-pulse&quot;>
                                <h3 class=&quot;font-semibold mb-2&quot;>Kernel Gaussiano</h3>
                                <canvas id=&quot;gaussKernelCanvas&quot; width=&quot;220&quot; height=&quot;160&quot; class=&quot;mx-auto&quot;></canvas>
                                <p class=&quot;text-sm mt-1 text-gray-600&quot;>Pesos según distancia</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class=&quot;bg-white p-4 rounded-lg shadow-md&quot;>
                    <h2 class=&quot;text-xl text-blue-700 mb-3&quot;>Comportamiento en los Bordes</h2>
                    <div class=&quot;flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4&quot;>
                        <div class=&quot;w-full sm:w-1/2&quot;>
                            <div class=&quot;kernel-3d h-40&quot;>
                                <canvas id=&quot;kernel3DVisual&quot; width=&quot;220&quot; height=&quot;160&quot; class=&quot;kernel-3d-surface mx-auto&quot;></canvas>
                            </div>
                            <p class=&quot;text-sm mt-2 text-gray-600 text-center&quot;>Visualización 3D del kernel gaussiano</p>
                        </div>
                        
                        <div class=&quot;w-full sm:w-1/2&quot;>
                            <canvas id=&quot;edgeTransitionCanvas&quot; width=&quot;220&quot; height=&quot;160&quot; class=&quot;mx-auto&quot;></canvas>
                            <div class=&quot;flex justify-center text-xs mt-1&quot;>
                                <div class=&quot;flex items-center mr-3&quot;>
                                    <div class=&quot;w-3 h-3 bg-red-500 mr-1 rounded-sm&quot;></div>
                                    <span>Kernel de Caja</span>
                                </div>
                                <div class=&quot;flex items-center&quot;>
                                    <div class=&quot;w-3 h-3 bg-blue-500 mr-1 rounded-sm&quot;></div>
                                    <span>Kernel Gaussiano</span>
                                </div>
                            </div>
                            <p class=&quot;text-sm mt-1 text-gray-600 text-center&quot;>Perfil de transición en bordes</p>
                        </div>
                    </div>
                </div>
                
                <div class=&quot;p-4 rounded-lg bg-blue-50 shadow-sm&quot;>
                    <h2 class=&quot;text-lg text-blue-700 mb-2&quot;>Ventaja Computacional: Kernel Separable</h2>
                    <div class=&quot;flex flex-col sm:flex-row items-center&quot;>
                        <div class=&quot;flex-1 mb-3 sm:mb-0 sm:mr-3&quot;>
                            <canvas id=&quot;separabilityDemo&quot; width=&quot;280&quot; height=&quot;120&quot; class=&quot;mx-auto&quot;></canvas>
                        </div>
                        <div class=&quot;flex-1 text-center sm:text-left&quot;>
                            <p class=&quot;text-sm text-gray-700&quot;><span class=&quot;font-bold&quot;>Kernel 2D</span>: O(N²) operaciones</p>
                            <p class=&quot;text-sm text-gray-700 mt-1&quot;><span class=&quot;font-bold&quot;>Kernel separable</span>: O(2N) operaciones</p>
                            <p class=&quot;text-sm font-bold text-blue-600 mt-1&quot;>¡Hasta N/2 veces más rápido (ej. N=512, ~256x)!</p> 
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class=&quot;mt-6 text-sm text-gray-600&quot;>
            <p class=&quot;text-center italic&quot;>&quot;Los kernels gaussianos deben ser más grandes que los filtros de caja para lograr el mismo grado de suavizado, ya que sus coeficientes decrecen con la distancia&quot;</p>
        </div>
    </div>

    <script>
        window.onload = function() {
            // Box Kernel Visualization
            const boxCtx = document.getElementById('boxKernelCanvas').getContext('2d');
            const boxSize = 150; // Size of the main square
            const boxMargin = (boxCtx.canvas.width - boxSize) / 2; // Center the box
            const perspectiveOffset = 15; // For the 3D effect

            boxCtx.fillStyle = '#f8fafc'; // Light background for the canvas
            boxCtx.fillRect(0, 0, boxCtx.canvas.width, boxCtx.canvas.height);
            
            // Top face
            boxCtx.beginPath();
            boxCtx.moveTo(boxMargin, boxMargin + perspectiveOffset);
            boxCtx.lineTo(boxMargin + boxSize, boxMargin + perspectiveOffset);
            boxCtx.lineTo(boxMargin + boxSize + perspectiveOffset, boxMargin);
            boxCtx.lineTo(boxMargin + perspectiveOffset, boxMargin);
            boxCtx.closePath();
            boxCtx.fillStyle = '#93c5fd'; // Light blue
            boxCtx.fill();
            boxCtx.strokeStyle = '#3b82f6'; // Darker blue border
            boxCtx.lineWidth = 1;
            boxCtx.stroke();
            
            // Front face
            boxCtx.fillStyle = '#60a5fa'; // Medium blue
            boxCtx.fillRect(boxMargin, boxMargin + perspectiveOffset, boxSize, boxSize);
            boxCtx.strokeStyle = '#3b82f6';
            boxCtx.strokeRect(boxMargin, boxMargin + perspectiveOffset, boxSize, boxSize);
            
            // Side face
            boxCtx.beginPath();
            boxCtx.moveTo(boxMargin + boxSize, boxMargin + perspectiveOffset);
            boxCtx.lineTo(boxMargin + boxSize + perspectiveOffset, boxMargin);
            boxCtx.lineTo(boxMargin + boxSize + perspectiveOffset, boxMargin + boxSize);
            boxCtx.lineTo(boxMargin + boxSize, boxMargin + perspectiveOffset + boxSize);
            boxCtx.closePath();
            boxCtx.fillStyle = '#3b82f6'; // Darker blue
            boxCtx.fill();
            boxCtx.strokeStyle = '#2563eb'; // Even darker border
            boxCtx.lineWidth = 1;
            boxCtx.stroke();
            
            // Uniform value text
            boxCtx.fillStyle = '#ffffff'; // White text
            boxCtx.font = 'bold 16px Arial';
            boxCtx.textAlign = 'center';
            boxCtx.textBaseline = 'middle';
            boxCtx.fillText('1/N²', boxMargin + boxSize/2, boxMargin + perspectiveOffset + boxSize/2);
            
            // Gaussian Kernel Visualization
            const gaussCtx = document.getElementById('gaussKernelCanvas').getContext('2d');
            const gaussCanvasWidth = gaussCtx.canvas.width;
            const gaussCanvasHeight = gaussCtx.canvas.height;
            const gaussPlotSize = Math.min(gaussCanvasWidth, gaussCanvasHeight) * 0.8; // Use 80% of smallest dimension
            const gaussMarginX = (gaussCanvasWidth - gaussPlotSize) / 2;
            const gaussMarginY = (gaussCanvasHeight - gaussPlotSize) / 2;
            
            gaussCtx.fillStyle = '#f8fafc';
            gaussCtx.fillRect(0, 0, gaussCanvasWidth, gaussCanvasHeight);
            
            const centerX = gaussMarginX + gaussPlotSize/2;
            const centerY = gaussMarginY + gaussPlotSize/2;
            const radius = gaussPlotSize / 2;
            
            const numCircles = 10;
            for (let i = numCircles; i >= 0; i--) {
                const currentRadius = (radius * (i / numCircles));
                const opacity = 0.9 - (i / numCircles) * 0.8;
                
                gaussCtx.beginPath();
                gaussCtx.arc(centerX, centerY, currentRadius, 0, Math.PI * 2);
                gaussCtx.fillStyle = `rgba(59, 130, 246, ${opacity})`;
                gaussCtx.fill();
            }
            
            const gradient = gaussCtx.createRadialGradient(
                centerX - radius/4, centerY - radius/4, 0,
                centerX, centerY, radius
            );
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            gaussCtx.fillStyle = gradient;
            gaussCtx.beginPath();
            gaussCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            gaussCtx.fill();
            
            // Draw bell curve shape on top (1D representation)
            gaussCtx.beginPath();
            gaussCtx.moveTo(gaussMarginX, gaussMarginY + gaussPlotSize);
            
            for (let x_val = 0; x_val <= gaussPlotSize; x_val++) {
                const normalizedX = x_val / gaussPlotSize;
                // Adjust amplitude and width of the bell curve to fit nicely
                const y_val = gaussPlotSize * 0.6 * Math.exp(-Math.pow((normalizedX - 0.5) * 4, 2)); 
                gaussCtx.lineTo(gaussMarginX + x_val, gaussMarginY + gaussPlotSize - y_val);
            }
            
            gaussCtx.strokeStyle = '#1e40af'; // Dark blue for the curve
            gaussCtx.lineWidth = 2;
            gaussCtx.stroke();
            
            // Edge Transition Visualization
            const edgeCtx = document.getElementById('edgeTransitionCanvas').getContext('2d');
            const edgeW = edgeCtx.canvas.width;
            const edgeH = edgeCtx.canvas.height;

            edgeCtx.fillStyle = '#f8fafc';
            edgeCtx.fillRect(0, 0, edgeW, edgeH);
            
            // Edge representation (black to white transition bar at the top)
            const barHeight = 30;
            const grdEdge = edgeCtx.createLinearGradient(0, 0, edgeW, 0);
            grdEdge.addColorStop(0, &quot;#374151&quot;); // Dark gray
            grdEdge.addColorStop(0.45, &quot;#374151&quot;); // Dark gray
            grdEdge.addColorStop(0.55, &quot;#e5e7eb&quot;); // Light gray
            grdEdge.addColorStop(1, &quot;#e5e7eb&quot;);   // Light gray
            
            edgeCtx.fillStyle = grdEdge;
            edgeCtx.fillRect(0, 10, edgeW, barHeight); // Bar at y=10, height=barHeight
            
            const plotStartY = barHeight + 20; // Start plotting below the bar
            const plotHeight = edgeH - plotStartY - 10; // Available height for plot
            const lowSignalY = plotStartY + plotHeight * 0.8; // Y for low signal (e.g., black)
            const highSignalY = plotStartY + plotHeight * 0.2; // Y for high signal (e.g., white)


            // Original edge profile (dashed line)
            edgeCtx.beginPath();
            edgeCtx.moveTo(0, lowSignalY);
            edgeCtx.lineTo(edgeW * 0.45, lowSignalY);
            edgeCtx.lineTo(edgeW * 0.55, highSignalY);
            edgeCtx.lineTo(edgeW, highSignalY);
            edgeCtx.strokeStyle = '#6b7280'; 
            edgeCtx.lineWidth = 1.5;
            edgeCtx.setLineDash([3, 3]); 
            edgeCtx.stroke();
            edgeCtx.setLineDash([]); 

            // Box Filter Transition (stair-like)
            edgeCtx.beginPath();
            const boxSteps = 5; // Number of steps in the transition
            const boxStepWidth = (edgeW * 0.1) / boxSteps; // Width of the transition zone for box
            const boxTransitionXStart = edgeW * 0.45;
            
            edgeCtx.moveTo(0, lowSignalY);
            edgeCtx.lineTo(boxTransitionXStart, lowSignalY);
            for(let i=0; i < boxSteps; i++) {
                const currentX = boxTransitionXStart + i * boxStepWidth;
                const nextX = boxTransitionXStart + (i+1) * boxStepWidth;
                const currentY = lowSignalY - ( (highSignalY - lowSignalY) / boxSteps ) * i ; // Flipped Y
                const nextY = lowSignalY - ( (highSignalY - lowSignalY) / boxSteps ) * (i+1) ; // Flipped Y
                edgeCtx.lineTo(currentX, currentY + ( (highSignalY - lowSignalY) / boxSteps ) ); // Horizontal part
                edgeCtx.lineTo(nextX, currentY + ( (highSignalY - lowSignalY) / boxSteps ) );   // Vertical part
            }
            edgeCtx.lineTo(boxTransitionXStart + (edgeW*0.1), highSignalY);
            edgeCtx.lineTo(edgeW, highSignalY);
            edgeCtx.lineWidth = 2;
            edgeCtx.strokeStyle = '#ef4444'; // Red-500
            edgeCtx.stroke();
            
            // Gaussian Filter Transition (smooth curve)
            edgeCtx.beginPath();
            edgeCtx.moveTo(0, lowSignalY);
            const gaussTransitionStart = 0.35 * edgeW;
            const gaussTransitionEnd = 0.65 * edgeW;

            for (let x_val = 0; x_val <= edgeW; x_val++) {
                let y_val;
                if (x_val < gaussTransitionStart) {
                    y_val = lowSignalY;
                } else if (x_val > gaussTransitionEnd) {
                    y_val = highSignalY;
                } else {
                    const t = (x_val - gaussTransitionStart) / (gaussTransitionEnd - gaussTransitionStart); // Normalize t
                    // Smoothstep function for a nice S-curve: t*t*(3-2*t)
                    // Apply to the difference between high and low, then add to low (or subtract from low if Y is inverted)
                    y_val = lowSignalY - (lowSignalY - highSignalY) * (t * t * (3 - 2 * t));
                }
                edgeCtx.lineTo(x_val, y_val);
            }
            edgeCtx.strokeStyle = '#3b82f6'; // Blue-500
            edgeCtx.lineWidth = 2;
            edgeCtx.stroke();
            
            // 3D Kernel Visualization
            const kernel3DCtx = document.getElementById('kernel3DVisual').getContext('2d');
            const k3DCanvasWidth = kernel3DCtx.canvas.width;
            const k3DCanvasHeight = kernel3DCtx.canvas.height;

            kernel3DCtx.fillStyle = '#f8fafc';
            kernel3DCtx.fillRect(0, 0, k3DCanvasWidth, k3DCanvasHeight);
            
            const k3DSize = Math.min(k3DCanvasWidth, k3DCanvasHeight) * 0.7; // Base size of the 3D shape
            const k3DMarginX = (k3DCanvasWidth - k3DSize) / 2;
            const k3DMarginY = (k3DCanvasHeight - k3DSize) / 2 + k3DSize * 0.1; // Shift down a bit

            const k3DCenterX = k3DMarginX + k3DSize / 2;
            const k3DCenterY = k3DMarginY + k3DSize / 2; // This will be the base center

            const perspectiveFactor = 0.4; // How much the ellipses shrink in Y for perspective

            for (let z = 20; z >= 0; z--) { // From back to front
                const heightRatio = z / 20; // 1 at the back, 0 at the front (peak)
                
                // Radius decreases towards the peak (front)
                const radiusX = (k3DSize / 2) * (1 - heightRatio * 0.8); 
                const radiusY = (k3DSize / 2 * perspectiveFactor) * (1 - heightRatio * 0.8);
                
                // Y offset increases towards the peak (front), making it appear taller
                const yOffset = (k3DSize * 0.4) * (1 - heightRatio); 
                
                const opacity = 0.3 + (1-heightRatio) * 0.7; // More opaque at the front/peak
                
                kernel3DCtx.beginPath();
                kernel3DCtx.ellipse(
                    k3DCenterX, k3DCenterY - yOffset, // Center Y shifts up for peak
                    radiusX, radiusY, 
                    0, 0, Math.PI * 2
                );
                
                const blueIntensity = Math.floor(150 + 105 * (1-heightRatio)); // Brighter blue at the peak
                kernel3DCtx.fillStyle = `rgba(59, 130, ${blueIntensity}, ${opacity})`;
                kernel3DCtx.fill();

                if (z % 3 === 0 && heightRatio < 0.9) { // Add some contour lines, not too many
                    kernel3DCtx.strokeStyle = `rgba(37, 99, 235, ${opacity * 0.5})`;
                    kernel3DCtx.lineWidth = 0.75;
                    kernel3DCtx.stroke();
                }
            }
            
            // Separability Demo
            const sepCtx = document.getElementById('separabilityDemo').getContext('2d');
            const sepW = sepCtx.canvas.width;
            const sepH = sepCtx.canvas.height;
            sepCtx.fillStyle = '#f8fafc'; // Background
            sepCtx.fillRect(0, 0, sepW, sepH);
            
            const marginS = 15;
            const opSize = Math.min(sepW / 4, sepH * 0.6); // Size of kernel representations
            const opY = (sepH - opSize) / 2; // Center vertically

            // 2D Kernel (left)
            const kernel2DX = marginS;
            const grd2D = sepCtx.createRadialGradient(
                kernel2DX + opSize/2, opY + opSize/2, 0,
                kernel2DX + opSize/2, opY + opSize/2, opSize/2
            );
            grd2D.addColorStop(0, &quot;rgba(59, 130, 246, 0.9)&quot;);
            grd2D.addColorStop(1, &quot;rgba(59, 130, 246, 0.2)&quot;);
            sepCtx.fillStyle = grd2D;
            sepCtx.fillRect(kernel2DX, opY, opSize, opSize);
            sepCtx.strokeStyle = '#3b82f6';
            sepCtx.strokeRect(kernel2DX, opY, opSize, opSize);
            
            // Arrow and equals sign
            const arrowXStart = kernel2DX + opSize + marginS/2;
            const arrowXEnd = arrowXStart + marginS;
            sepCtx.beginPath();
            sepCtx.moveTo(arrowXStart, sepH/2);
            sepCtx.lineTo(arrowXEnd, sepH/2);
            sepCtx.lineWidth = 2;
            sepCtx.strokeStyle = '#4b5563'; // Gray-700
            sepCtx.stroke();
            sepCtx.fillText(&quot;=&quot;, arrowXStart + marginS/4 , sepH/2 - 10); // Equals sign above arrow

            sepCtx.beginPath(); // Arrowhead
            sepCtx.moveTo(arrowXEnd, sepH/2);
            sepCtx.lineTo(arrowXEnd - 5, sepH/2 - 4);
            sepCtx.moveTo(arrowXEnd, sepH/2);
            sepCtx.lineTo(arrowXEnd - 5, sepH/2 + 4);
            sepCtx.stroke();
            
            // 1D horizontal kernel
            const kernel1DX = arrowXEnd + marginS/2;
            sepCtx.beginPath();
            sepCtx.moveTo(kernel1DX, opY + opSize); // Start at bottom left of its area
            for (let x = 0; x <= opSize; x++) {
                const normalizedX = x / opSize;
                const y_amp = opSize * 0.4 * Math.exp(-Math.pow((normalizedX - 0.5) * 4, 2)); // Amplitude for 1D curve
                sepCtx.lineTo(kernel1DX + x, opY + opSize - y_amp);
            }
            sepCtx.strokeStyle = '#3b82f6';
            sepCtx.lineWidth = 2;
            sepCtx.stroke();
            // Base line for 1D horizontal
            sepCtx.beginPath();
            sepCtx.moveTo(kernel1DX, opY + opSize);
            sepCtx.lineTo(kernel1DX + opSize, opY + opSize);
            sepCtx.strokeStyle = '#9ca3af'; // Gray-400
            sepCtx.lineWidth = 1;
            sepCtx.stroke();

            // Multiplication symbol
            const multiplyX = kernel1DX + opSize + marginS/2;
            sepCtx.font = 'bold 20px Arial';
            sepCtx.fillStyle = '#4b5563';
            sepCtx.textAlign = 'center';
            sepCtx.fillText('⊗', multiplyX, sepH/2 + 7); // Centered vertically
            
            // 1D vertical kernel
            const kernel1DYX = multiplyX + marginS/2; // X position for vertical kernel
            sepCtx.beginPath();
            sepCtx.moveTo(kernel1DYX, opY); // Start at top left of its area
            for (let y = 0; y <= opSize; y++) {
                const normalizedY = y / opSize;
                const x_amp = opSize * 0.4 * Math.exp(-Math.pow((normalizedY - 0.5) * 4, 2));
                sepCtx.lineTo(kernel1DYX + x_amp, opY + y);
            }
            sepCtx.strokeStyle = '#3b82f6';
            sepCtx.lineWidth = 2;
            sepCtx.stroke();
             // Base line for 1D vertical
            sepCtx.beginPath();
            sepCtx.moveTo(kernel1DYX, opY);
            sepCtx.lineTo(kernel1DYX, opY + opSize);
            sepCtx.strokeStyle = '#9ca3af';
            sepCtx.lineWidth = 1;
            sepCtx.stroke();
            
            // Small test image examples
            const originalCtx = document.getElementById('originalImageSmall').getContext('2d');
            const blurCtx = document.getElementById('gaussBlurImageSmall').getContext('2d');
            
            drawTestPattern(originalCtx, 0); // No blur for original
            drawTestPattern(blurCtx, 3);   // Apply 3px blur for the filtered image
        };
        
        /**
         * Draws a test pattern on the given canvas context.
         * Applies a blur effect if blurAmount > 0.
         * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
         * @param {number} blurAmount - The amount of blur in pixels.
         */
        function drawTestPattern(ctx, blurAmount) {
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;
            
            const originalFilter = ctx.filter; 

            if (blurAmount > 0) {
                ctx.filter = `blur(${blurAmount}px)`;
            } else {
                ctx.filter = 'none'; 
            }

            ctx.fillStyle = '#f0f4f8'; // Light gray background, consistent with slide
            ctx.fillRect(0, 0, w, h);

            const gridSize = Math.min(w,h) / 6; // Make grid size relative
            for (let y = 0; y < h; y += gridSize) {
                for (let x = 0; x < w; x += gridSize) {
                    if ((Math.floor(x / gridSize) + Math.floor(y / gridSize)) % 2 === 0) {
                        ctx.fillStyle = &quot;#4b5563&quot;; 
                    } else {
                        ctx.fillStyle = &quot;#d1d5db&quot;; // Lighter gray for &quot;white&quot; squares
                    }
                    ctx.fillRect(x, y, gridSize, gridSize);
                }
            }
            
            ctx.font = `bold ${Math.min(w,h)*0.5}px Arial`; // Relative font size
            ctx.fillStyle = &quot;#c53030&quot;; // Darker Red
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // Adjust text position slightly if needed after blur, though blur itself often handles this
            ctx.fillText('A', w / 2, h / 2 + Math.min(w,h)*0.03); 

            ctx.filter = originalFilter; // Restore
        }
    </script>
</body>
</html>
" style="width:100%; height:100%; border:none;" sandbox="allow-scripts allow-same-origin allow-popups allow-forms allow-presentation"></iframe>
                    </section>
            </div>

            <div class="presentation-slide " id="export-slide-mb13vzzsc4v0k">
                <section class="slide" style="background: linear-gradient(to bottom right, #3B82F6, #1E40AF); color: #FFFFFF; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; box-sizing: border-box; padding: 0;">
                        <iframe srcdoc="<!DOCTYPE html>
<html lang=&quot;es&quot;>
<head>
    <meta charset=&quot;UTF-8&quot;>
    <meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;>
    <title>Comparación entre Filtros Gaussianos y de Caja</title>
    <link href=&quot;https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css&quot; rel=&quot;stylesheet&quot;>
    <link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css&quot;>
    <script src=&quot;https://cdn.jsdelivr.net/npm/chart.js&quot;></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f4f8;
            font-family: 'Arial', sans-serif;
        }
        .slide {
            width: 1280px;
            min-height: 720px;
            background: linear-gradient(135deg, #ffffff 0%, #f0f4f8 100%);
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        .title {
            font-weight: 700;
            color: #2c5282;
        }
        .image-comparison {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            position: relative;
        }
        .image-box {
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background-color: #f8fafc;
            position: relative;
        }
        .image-label {
            position: absolute;
            bottom: 0;
            left: 0;
            background-color: rgba(49, 130, 206, 0.8);
            color: white;
            padding: 2px 8px;
            border-radius: 0 4px 0 0;
            font-size: 0.75rem;
        }
        .parameter-box {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        .formula-box {
            background-color: rgba(237, 242, 247, 0.8);
            border-radius: 8px;
            padding: 1rem;
        }
        .key-point {
            position: relative;
            padding-left: 20px;
        }
        .key-point:before {
            content: &quot;&quot;;
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background-color: #3182ce;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class=&quot;slide flex flex-col p-10&quot;>
        <h1 class=&quot;title text-4xl mb-4 text-center&quot;>Comparación entre Filtros Gaussianos y de Caja</h1>
        <div class=&quot;w-20 h-1 bg-blue-600 rounded-full mb-6 mx-auto&quot;></div>
        
        <!-- Main content grid -->
        <div class=&quot;grid grid-cols-3 gap-6 flex-1&quot;>
            
            <!-- Left column - Image comparisons -->
            <div class=&quot;col-span-2 image-comparison p-4&quot;>
                <h2 class=&quot;text-xl text-blue-700 mb-3&quot;>Resultados de Filtrado (Ejemplo 3.12)</h2>
                
                <div class=&quot;grid grid-cols-3 gap-4 mb-4&quot;>
                    <div class=&quot;image-box h-48 overflow-hidden flex justify-center items-center relative&quot;>
                        <canvas id=&quot;originalImage&quot; width=&quot;200&quot; height=&quot;180&quot;></canvas>
                        <div class=&quot;image-label&quot;>Imagen Original</div>
                    </div>
                    
                    <div class=&quot;image-box h-48 overflow-hidden flex justify-center items-center relative&quot;>
                        <canvas id=&quot;boxFilteredImage&quot; width=&quot;200&quot; height=&quot;180&quot;></canvas>
                        <div class=&quot;image-label&quot;>Filtro de Caja</div>
                    </div>
                    
                    <div class=&quot;image-box h-48 overflow-hidden flex justify-center items-center relative&quot;>
                        <canvas id=&quot;gaussFilteredImage&quot; width=&quot;200&quot; height=&quot;180&quot;></canvas>
                        <div class=&quot;image-label&quot;>Filtro Gaussiano</div>
                    </div>
                </div>
                
                <!-- Parameter comparison -->
                <div class=&quot;grid grid-cols-2 gap-4&quot;>
                    <div class=&quot;parameter-box p-3&quot;>
                        <h3 class=&quot;text-lg font-semibold text-blue-600 mb-2&quot;>Kernel Gaussiano</h3>
                        <ul class=&quot;text-sm space-y-2 text-gray-700&quot;>
                            <li><span class=&quot;font-semibold&quot;>Tamaño:</span> Debe ser mayor que el de caja para similar desenfoque</li>
                            <li><span class=&quot;font-semibold&quot;>Fórmula 2D:</span> <span class=&quot;formula-box inline-block&quot;>G(x,y) = (1/2πσ²)e^(-(x²+y²)/2σ²)</span></li>
                            <li><span class=&quot;font-semibold&quot;>Pesos:</span> Decrecen con la distancia al centro</li>
                            <li><span class=&quot;font-semibold&quot;>Bordes:</span> Transiciones suaves, sin artefactos</li>
                        </ul>
                    </div>
                    
                    <div class=&quot;parameter-box p-3&quot;>
                        <h3 class=&quot;text-lg font-semibold text-red-600 mb-2&quot;>Kernel de Caja</h3>
                        <ul class=&quot;text-sm space-y-2 text-gray-700&quot;>
                            <li><span class=&quot;font-semibold&quot;>Tamaño:</span> Menor que el gaussiano para similar desenfoque</li>
                            <li><span class=&quot;font-semibold&quot;>Fórmula:</span> <span class=&quot;formula-box inline-block&quot;>B(x,y) = 1/N² para todo x,y en N×N</span></li>
                            <li><span class=&quot;font-semibold&quot;>Pesos:</span> Uniformes en toda la ventana</li>
                            <li><span class=&quot;font-semibold&quot;>Bordes:</span> Transiciones abruptas, posibles artefactos</li>
                        </ul>
                    </div>
                </div>
                
                <div class=&quot;mt-4&quot;>
                    <div class=&quot;text-sm text-gray-600 italic&quot;>
                        &quot;Los kernels gaussianos tienen que ser más grandes que los filtros de caja para lograr el mismo grado de desenfoque.&quot;
                    </div>
                </div>
            </div>
            
            <!-- Right column - Key points -->
            <div class=&quot;flex flex-col space-y-4&quot;>
                <div class=&quot;bg-white p-4 rounded-lg shadow-md flex-1&quot;>
                    <h2 class=&quot;text-xl text-blue-700 mb-3&quot;>Observaciones Clave</h2>
                    
                    <div class=&quot;space-y-4 text-gray-700&quot;>
                        <p class=&quot;key-point&quot;>Para similar desenfoque, kernel gaussiano 21×21 (σ=3.5) ≈ box 15×15</p>
                        
                        <p class=&quot;key-point&quot;>Kernel gaussiano 43×43 (σ=7) produce menos desenfoque que su equivalente de caja</p>
                        
                        <p class=&quot;key-point&quot;>Gaussian proporciona suavizado más natural en los bordes</p>
                        
                        <p class=&quot;key-point&quot;>Relación entre σ y tamaño: ~6σ × 6σ para capturar >99% de la distribución</p>
                        
                        <p class=&quot;key-point&quot;>Eficiencia computacional: gaussiano 2D es separable en dos filtros 1D</p>
                    </div>
                </div>
                
                <div class=&quot;bg-white p-4 rounded-lg shadow-md&quot;>
                    <h2 class=&quot;text-xl text-blue-700 mb-3&quot;>Efecto en los Bordes</h2>
                    <div class=&quot;h-40 overflow-hidden&quot;>
                        <canvas id=&quot;edgeProfile&quot; width=&quot;350&quot; height=&quot;160&quot;></canvas>
                    </div>
                    <div class=&quot;flex justify-center text-xs text-gray-500 mt-2&quot;>
                        <div class=&quot;flex items-center mr-4&quot;>
                            <div class=&quot;w-3 h-3 bg-red-500 mr-1&quot;></div>
                            <span>Box Kernel</span>
                        </div>
                        <div class=&quot;flex items-center&quot;>
                            <div class=&quot;w-3 h-3 bg-blue-500 mr-1&quot;></div>
                            <span>Gaussian Kernel</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        window.onload = function() {
            // Original Image simulation
            const originalCtx = document.getElementById('originalImage').getContext('2d');
            drawTestPattern(originalCtx, 0);
            
            // Box filtered image simulation
            const boxCtx = document.getElementById('boxFilteredImage').getContext('2d');
            drawTestPattern(boxCtx, 10);
            
            // Gauss filtered image simulation
            const gaussCtx = document.getElementById('gaussFilteredImage').getContext('2d');
            drawTestPattern(gaussCtx, 5);
            
            // Edge profile chart
            const edgeCtx = document.getElementById('edgeProfile').getContext('2d');
            
            // Draw background
            edgeCtx.fillStyle = '#f8fafc';
            edgeCtx.fillRect(0, 0, 350, 160);
            
            // Draw axes
            edgeCtx.beginPath();
            edgeCtx.moveTo(30, 130);
            edgeCtx.lineTo(320, 130);
            edgeCtx.moveTo(30, 130);
            edgeCtx.lineTo(30, 30);
            edgeCtx.strokeStyle = '#718096';
            edgeCtx.lineWidth = 1;
            edgeCtx.stroke();
            
            // Draw box filter response (step-like)
            edgeCtx.beginPath();
            edgeCtx.moveTo(30, 130);
            edgeCtx.lineTo(120, 130);
            edgeCtx.lineTo(120, 40);
            edgeCtx.lineTo(200, 40);
            edgeCtx.lineTo(200, 130);
            edgeCtx.strokeStyle = '#e53e3e';
            edgeCtx.lineWidth = 3;
            edgeCtx.stroke();
            
            // Draw gaussian filter response (smooth)
            edgeCtx.beginPath();
            edgeCtx.moveTo(30, 130);
            
            for (let x = 30; x <= 320; x++) {
                const normalizedX = (x - 30) / 290; // 0 to 1
                let y;
                
                if (normalizedX < 0.3) {
                    y = 130;
                } else if (normalizedX > 0.7) {
                    y = 130;
                } else {
                    y = 130 - 90 * (1/(1 + Math.exp(-12*(normalizedX - 0.5))));
                }
                
                edgeCtx.lineTo(x, y);
            }
            
            edgeCtx.strokeStyle = '#3182ce';
            edgeCtx.lineWidth = 3;
            edgeCtx.stroke();
            
            // Labels
            edgeCtx.fillStyle = '#4a5568';
            edgeCtx.font = '10px Arial';
            edgeCtx.fillText('Perfil de Intensidad en Bordes', 120, 150);
        };
        
        function drawTestPattern(ctx, blurAmount) {
            // Set background
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, 200, 180);
            
            // Draw test pattern with simulated blur
            
            // Grid pattern
            const gridSize = 20;
            for(let x = 0; x < 200; x += gridSize) {
                for(let y = 0; y < 180; y += gridSize) {
                    if((x/gridSize + y/gridSize) % 2 === 0) {
                        ctx.fillStyle = '#2d3748';
                        
                        if(blurAmount > 0) {
                            // Simulate blur with semi-transparent larger rectangle
                            ctx.globalAlpha = 0.6;
                            ctx.fillRect(
                                x - blurAmount/2, 
                                y - blurAmount/2, 
                                gridSize + blurAmount, 
                                gridSize + blurAmount
                            );
                            ctx.globalAlpha = 1;
                        } else {
                            ctx.fillRect(x, y, gridSize, gridSize);
                        }
                    }
                }
            }
            
            // Add large letter 'a' in center
            ctx.font = '80px Arial';
            ctx.fillStyle = '#000000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            if(blurAmount > 0) {
                // Simulate blur with multiple semi-transparent letters
                ctx.globalAlpha = 0.2;
                for(let i = 0; i < 5; i++) {
                    const offset = (blurAmount/4) * (i - 2);
                    ctx.fillText('a', 100 + offset, 90 + offset);
                }
                ctx.globalAlpha = 0.6;
                ctx.fillText('a', 100, 90);
                ctx.globalAlpha = 1;
            } else {
                ctx.fillText('a', 100, 90);
            }
            
            // Add horizontal lines at bottom
            const lineY = 130;
            const lineSpacing = 10;
            const lineWidth = 60;
            
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#000000';
            
            for(let i = 0; i < 3; i++) {
                const y = lineY + i * lineSpacing;
                
                if(blurAmount > 0) {
                    // Simulate blur with multiple semi-transparent lines
                    ctx.globalAlpha = 0.2;
                    for(let j = 0; j < 5; j++) {
                        const offset = (blurAmount/8) * (j - 2);
                        ctx.beginPath();
                        ctx.moveTo(100 - lineWidth/2, y + offset);
                        ctx.lineTo(100 + lineWidth/2, y + offset);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.moveTo(100 - lineWidth/2, y);
                    ctx.lineTo(100 + lineWidth/2, y);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                } else {
                    ctx.beginPath();
                    ctx.moveTo(100 - lineWidth/2, y);
                    ctx.lineTo(100 + lineWidth/2, y);
                    ctx.stroke();
                }
            }
        }
    </script>
</body>
</html>" style="width:100%; height:100%; border:none;" sandbox="allow-scripts allow-same-origin allow-popups allow-forms allow-presentation"></iframe>
                    </section>
            </div>

            <div class="presentation-slide " id="export-slide-mb13wz1wtwjpt">
                <section class="slide" style="background: linear-gradient(to bottom right, #3B82F6, #1E40AF); color: #FFFFFF; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; box-sizing: border-box; padding: 0;">
                        <iframe srcdoc="<!DOCTYPE html>
<html lang=&quot;es&quot;>
<head>
    <meta charset=&quot;UTF-8&quot;>
    <meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;>
    <title>Métodos de Padding y Efecto del Tamaño del Kernel</title>
    <link href=&quot;https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css&quot; rel=&quot;stylesheet&quot;>
    <link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css&quot;>
    <script src=&quot;https://cdn.jsdelivr.net/npm/chart.js&quot;></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f4f8;
            font-family: 'Arial', sans-serif;
        }
        .slide {
            width: 1280px;
            min-height: 720px;
            background: linear-gradient(135deg, #ffffff 0%, #f0f4f8 100%);
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        .title {
            font-weight: 700;
            color: #2c5282;
        }
        .content-box {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .image-container {
            position: relative;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background-color: #f8fafc;
            overflow: hidden;
        }
        .image-label {
            position: absolute;
            bottom: 0;
            left: 0;
            background-color: rgba(49, 130, 206, 0.8);
            color: white;
            padding: 2px 8px;
            border-radius: 0 4px 0 0;
            font-size: 0.75rem;
        }
        .key-point {
            position: relative;
            padding-left: 20px;
        }
        .key-point:before {
            content: &quot;&quot;;
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            background-color: #3182ce;
            border-radius: 50%;
        }
        .formula {
            background-color: rgba(237, 242, 247, 0.8);
            border-radius: 4px;
            padding: 4px 8px;
            display: inline-block;
            font-family: 'Times New Roman', serif;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class=&quot;slide flex flex-col p-10&quot;>
        <h1 class=&quot;title text-4xl mb-4 text-center&quot;>Métodos de Padding y Efecto del Tamaño del Kernel</h1>
        <div class=&quot;w-20 h-1 bg-blue-600 rounded-full mb-6 mx-auto&quot;></div>
        
        <!-- Main grid layout -->
        <div class=&quot;grid grid-cols-2 gap-6&quot;>
            <!-- Left column - Padding methods -->
            <div class=&quot;content-box p-5&quot;>
                <h2 class=&quot;text-xl text-blue-700 mb-4&quot;>Tipos de Padding en Filtrado Gaussiano</h2>
                
                <div class=&quot;grid grid-cols-3 gap-3 mb-4&quot;>
                    <div class=&quot;image-container h-40 flex justify-center items-center&quot;>
                        <canvas id=&quot;zeroPadding&quot; width=&quot;140&quot; height=&quot;140&quot;></canvas>
                        <div class=&quot;image-label&quot;>Zero Padding</div>
                    </div>
                    
                    <div class=&quot;image-container h-40 flex justify-center items-center&quot;>
                        <canvas id=&quot;mirrorPadding&quot; width=&quot;140&quot; height=&quot;140&quot;></canvas>
                        <div class=&quot;image-label&quot;>Mirror Padding</div>
                    </div>
                    
                    <div class=&quot;image-container h-40 flex justify-center items-center&quot;>
                        <canvas id=&quot;replicatePadding&quot; width=&quot;140&quot; height=&quot;140&quot;></canvas>
                        <div class=&quot;image-label&quot;>Replicate Padding</div>
                    </div>
                </div>
                
                <div class=&quot;space-y-3 text-gray-700 text-sm&quot;>
                    <p class=&quot;key-point&quot;>Zero padding: Añade valores cero fuera de los bordes, genera bordes oscuros</p>
                    <p class=&quot;key-point&quot;>Mirror padding (simétrico): Refleja valores a través del borde</p>
                    <p class=&quot;key-point&quot;>Replicate padding: Repite el valor más cercano del borde</p>
                </div>
                
                <div class=&quot;mt-4 p-3 bg-blue-50 rounded-md&quot;>
                    <p class=&quot;text-sm text-gray-600&quot;>
                        <span class=&quot;font-semibold text-blue-700&quot;>Recomendación:</span> 
                        Usar mirror padding cuando hay detalles importantes cerca del borde.
                        Usar replicate padding cuando las áreas de borde son constantes.
                    </p>
                </div>
            </div>
            
            <!-- Right column - Kernel size effects -->
            <div class=&quot;content-box p-5&quot;>
                <h2 class=&quot;text-xl text-blue-700 mb-4&quot;>Efecto del Tamaño del Kernel y la Imagen</h2>
                
                <div class=&quot;flex space-x-4 mb-4&quot;>
                    <div class=&quot;image-container w-1/2 h-40 flex justify-center items-center&quot;>
                        <canvas id=&quot;smallImage&quot; width=&quot;140&quot; height=&quot;140&quot;></canvas>
                        <div class=&quot;image-label&quot;>Imagen Pequeña</div>
                    </div>
                    
                    <div class=&quot;image-container w-1/2 h-40 flex justify-center items-center&quot;>
                        <canvas id=&quot;largeImage&quot; width=&quot;140&quot; height=&quot;140&quot;></canvas>
                        <div class=&quot;image-label&quot;>Imagen Grande</div>
                    </div>
                </div>
                
                <div class=&quot;space-y-3 text-gray-700 text-sm&quot;>
                    <p class=&quot;key-point&quot;>El efecto de desenfoque depende del tamaño relativo del kernel vs. la imagen</p>
                    <p class=&quot;key-point&quot;>Al aumentar las dimensiones de la imagen 4×, el kernel debe aumentar su tamaño en 4× para mantener el mismo desenfoque</p>
                    <p class=&quot;key-point&quot;>Ejemplo: Kernel 43×43 (σ=7) en imagen 1024×1024 ≈ Kernel 172×172 (σ=28) en imagen 4096×4096</p>
                </div>
                
                <div class=&quot;mt-4 p-3 bg-blue-50 rounded-md&quot;>
                    <p class=&quot;text-sm font-semibold text-blue-700&quot;>Fórmula de escalamiento:</p>
                    <p class=&quot;text-sm text-gray-600 mt-1&quot;>
                        Si aumentamos una imagen por un factor <span class=&quot;formula&quot;>f</span>, el kernel debe escalarse con el mismo factor para mantener el efecto visual:
                    </p>
                    <div class=&quot;text-center mt-2&quot;>
                        <p class=&quot;formula&quot;>σ_nuevo = f × σ_original</p>
                        <p class=&quot;formula&quot;>tamaño_nuevo = f × tamaño_original</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Bottom section - Kernel separability -->
        <div class=&quot;content-box p-5 mt-6&quot;>
            <h2 class=&quot;text-xl text-blue-700 mb-3&quot;>Ventaja Computacional: Separabilidad del Kernel Gaussiano</h2>
            
            <div class=&quot;flex items-center&quot;>
                <div class=&quot;w-1/3&quot;>
                    <canvas id=&quot;kernelSeparability&quot; width=&quot;250&quot; height=&quot;150&quot;></canvas>
                </div>
                
                <div class=&quot;w-2/3 pl-6 space-y-3 text-sm text-gray-700&quot;>
                    <p class=&quot;key-point&quot;>El kernel Gaussiano 2D es <span class=&quot;font-bold text-blue-600&quot;>separable</span>: puede aplicarse como dos filtrados 1D consecutivos</p>
                    <p class=&quot;key-point&quot;>Complejidad computacional reducida: Para kernel N×N, O(N²) → O(2N)</p>
                    <p class=&quot;key-point&quot;>Ejemplo: Kernel 187×187 directo: 2.2 horas vs. Kernel separable: 30 segundos</p>
                    <p class=&quot;key-point&quot;>Ventaja aumenta con el tamaño del kernel: 262:1 para kernel 512×512</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        window.onload = function() {
            // Zero Padding visualization
            const zeroCtx = document.getElementById('zeroPadding').getContext('2d');
            drawPaddingExample(zeroCtx, 'zero');
            
            // Mirror Padding visualization
            const mirrorCtx = document.getElementById('mirrorPadding').getContext('2d');
            drawPaddingExample(mirrorCtx, 'mirror');
            
            // Replicate Padding visualization
            const replicateCtx = document.getElementById('replicatePadding').getContext('2d');
            drawPaddingExample(replicateCtx, 'replicate');
            
            // Small Image with blur visualization
            const smallCtx = document.getElementById('smallImage').getContext('2d');
            drawBlurSizeExample(smallCtx, 'small');
            
            // Large Image with blur visualization
            const largeCtx = document.getElementById('largeImage').getContext('2d');
            drawBlurSizeExample(largeCtx, 'large');
            
            // Kernel Separability visualization
            const sepCtx = document.getElementById('kernelSeparability').getContext('2d');
            drawSeparabilityExample(sepCtx);
        };
        
        function drawPaddingExample(ctx, paddingType) {
            // Base image is a gradient with a pattern
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;
            const centerSize = Math.min(w, h) * 0.65;
            const borderSize = Math.min(w, h) * 0.175;
            
            // Draw background
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, w, h);
            
            // Draw inner content (simulated image)
            const startX = (w - centerSize) / 2;
            const startY = (h - centerSize) / 2;
            
            // Inner content - pattern
            const gradient = ctx.createLinearGradient(startX, startY, startX + centerSize, startY + centerSize);
            gradient.addColorStop(0, '#3182ce');
            gradient.addColorStop(1, '#9f7aea');
            ctx.fillStyle = gradient;
            ctx.fillRect(startX, startY, centerSize, centerSize);
            
            // Draw letter in center
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('a', w/2, h/2);
            
            // Draw padding based on type
            ctx.lineWidth = 1;
            
            // Border area
            if (paddingType === 'zero') {
                ctx.fillStyle = '#000000';
                // Top border
                ctx.fillRect(0, 0, w, startY);
                // Bottom border
                ctx.fillRect(0, startY + centerSize, w, startY);
                // Left border
                ctx.fillRect(0, startY, startX, centerSize);
                // Right border
                ctx.fillRect(startX + centerSize, startY, startX, centerSize);
                
            } else if (paddingType === 'mirror') {
                // Simulate mirrored content with gradients
                // Top border
                const topGrad = ctx.createLinearGradient(0, startY, 0, 0);
                topGrad.addColorStop(0, '#3182ce');
                topGrad.addColorStop(1, '#9f7aea');
                ctx.fillStyle = topGrad;
                ctx.fillRect(startX, 0, centerSize, startY);
                
                // Bottom border
                const bottomGrad = ctx.createLinearGradient(0, startY + centerSize, 0, h);
                bottomGrad.addColorStop(0, '#9f7aea');
                bottomGrad.addColorStop(1, '#3182ce');
                ctx.fillStyle = bottomGrad;
                ctx.fillRect(startX, startY + centerSize, centerSize, startY);
                
                // Left border
                const leftGrad = ctx.createLinearGradient(startX, 0, 0, 0);
                leftGrad.addColorStop(0, '#3182ce');
                leftGrad.addColorStop(1, '#9f7aea');
                ctx.fillStyle = leftGrad;
                ctx.fillRect(0, startY, startX, centerSize);
                
                // Right border
                const rightGrad = ctx.createLinearGradient(startX + centerSize, 0, w, 0);
                rightGrad.addColorStop(0, '#9f7aea');
                rightGrad.addColorStop(1, '#3182ce');
                ctx.fillStyle = rightGrad;
                ctx.fillRect(startX + centerSize, startY, startX, centerSize);
                
            } else if (paddingType === 'replicate') {
                // Replicate the border color
                // Top border
                ctx.fillStyle = '#3182ce';
                ctx.fillRect(startX, 0, centerSize, startY);
                
                // Bottom border
                ctx.fillStyle = '#9f7aea';
                ctx.fillRect(startX, startY + centerSize, centerSize, startY);
                
                // Left border
                ctx.fillStyle = '#3182ce';
                ctx.fillRect(0, startY, startX, centerSize);
                
                // Right border
                ctx.fillStyle = '#9f7aea';
                ctx.fillRect(startX + centerSize, startY, startX, centerSize);
                
                // Corner fills
                ctx.fillStyle = '#3182ce';
                ctx.fillRect(0, 0, startX, startY); // Top-left
                ctx.fillStyle = '#3182ce';
                ctx.fillRect(startX + centerSize, 0, startX, startY); // Top-right
                ctx.fillStyle = '#9f7aea';
                ctx.fillRect(0, startY + centerSize, startX, startY); // Bottom-left
                ctx.fillStyle = '#9f7aea';
                ctx.fillRect(startX + centerSize, startY + centerSize, startX, startY); // Bottom-right
            }
            
            // Draw border to show image boundary
            ctx.strokeStyle = '#cbd5e0';
            ctx.strokeRect(startX, startY, centerSize, centerSize);
        }
        
        function drawBlurSizeExample(ctx, imageSize) {
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;
            
            // Background
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, w, h);
            
            // Create test pattern
            const patternSize = imageSize === 'small' ? 20 : 10; // Smaller squares for &quot;large&quot; image (simulating higher resolution)
            
            for(let x = 0; x < w; x += patternSize) {
                for(let y = 0; y < h; y += patternSize) {
                    if((Math.floor(x/patternSize) + Math.floor(y/patternSize)) % 2 === 0) {
                        ctx.fillStyle = '#2d3748';
                        ctx.fillRect(x, y, patternSize, patternSize);
                    }
                }
            }
            
            // Add big A in center
            ctx.font = imageSize === 'small' ? 'bold 50px Arial' : 'bold 30px Arial';
            ctx.fillStyle = '#000000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('a', w/2, h/2);
            
            // Apply blur effect (simulated)
            const blurAmount = imageSize === 'small' ? 12 : 3; // More blur on small image
            
            ctx.save();
            ctx.filter = `blur(${blurAmount}px)`;
            ctx.clearRect(0, 0, w, h);
            
            // Draw blurred pattern
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, w, h);
            
            for(let x = 0; x < w; x += patternSize) {
                for(let y = 0; y < h; y += patternSize) {
                    if((Math.floor(x/patternSize) + Math.floor(y/patternSize)) % 2 === 0) {
                        ctx.fillStyle = '#2d3748';
                        ctx.fillRect(x, y, patternSize, patternSize);
                    }
                }
            }
            
            // Add blurred A
            ctx.font = imageSize === 'small' ? 'bold 50px Arial' : 'bold 30px Arial';
            ctx.fillStyle = '#000000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('a', w/2, h/2);
            
            ctx.restore();
            
            // Add kernel size indicator
            ctx.fillStyle = 'rgba(49, 130, 206, 0.3)';
            const kernelSize = imageSize === 'small' ? 50 : 25;
            ctx.fillRect(w/2 - kernelSize/2, h/2 - kernelSize/2, kernelSize, kernelSize);
            ctx.strokeStyle = 'rgba(49, 130, 206, 0.8)';
            ctx.lineWidth = 1;
            ctx.strokeRect(w/2 - kernelSize/2, h/2 - kernelSize/2, kernelSize, kernelSize);
            
            // Add kernel size text
            ctx.font = '10px Arial';
            ctx.fillStyle = '#4a5568';
            ctx.textAlign = 'center';
            const kernelText = imageSize === 'small' ? 'Kernel: 43×43, σ=7' : 'Kernel: 172×172, σ=28';
            ctx.fillText(kernelText, w/2, h - 10);
        }
        
        function drawSeparabilityExample(ctx) {
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;
            
            // Draw background
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, w, h);
            
            const margin = 20;
            const separatorY = h * 0.65;
            
            // 2D Kernel section
            ctx.fillStyle = 'rgba(49, 130, 206, 0.1)';
            ctx.fillRect(margin, margin, w - 2*margin, separatorY - 2*margin);
            
            // Gaussian 2D
            const centerX = w/2;
            const centerY = separatorY/2;
            const radius = Math.min(w, separatorY) / 4;
            
            const gradient = ctx.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius
            );
            gradient.addColorStop(0, 'rgba(49, 130, 206, 0.8)');
            gradient.addColorStop(1, 'rgba(49, 130, 206, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Label for 2D
            ctx.font = 'bold 12px Arial';
            ctx.fillStyle = '#4a5568';
            ctx.textAlign = 'center';
            ctx.fillText('Kernel Gaussiano 2D', centerX, margin + 15);
            
            // Arrow
            ctx.fillStyle = '#4a5568';
            ctx.beginPath();
            ctx.moveTo(centerX, separatorY - margin/2);
            ctx.lineTo(centerX - 10, separatorY - margin/2 - 10);
            ctx.lineTo(centerX + 10, separatorY - margin/2 - 10);
            ctx.fill();
            
            // Equals sign
            ctx.fillStyle = '#4a5568';
            ctx.font = 'bold 20px Arial';
            ctx.fillText('=', centerX, separatorY + (h - separatorY)/2);
            
            // 1D kernels
            const kernelHeight = (h - separatorY - 3*margin) / 2;
            
            // Horizontal kernel
            ctx.fillStyle = 'rgba(49, 130, 206, 0.1)';
            ctx.fillRect(margin, separatorY + margin, w - 2*margin, kernelHeight);
            
            // 1D horizontal gaussian
            ctx.beginPath();
            ctx.moveTo(margin, separatorY + margin + kernelHeight/2);
            
            for(let x = margin; x <= w - margin; x++) {
                const normalized = (x - margin) / (w - 2*margin);
                const y = separatorY + margin + kernelHeight/2 - Math.exp(-Math.pow((normalized-0.5)*5, 2)) * kernelHeight/2;
                ctx.lineTo(x, y);
            }
            
            ctx.strokeStyle = 'rgba(49, 130, 206, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Label for horizontal
            ctx.font = '10px Arial';
            ctx.fillStyle = '#4a5568';
            ctx.textAlign = 'left';
            ctx.fillText('Kernel Gaussiano 1D (horizontal)', margin + 5, separatorY + margin + 12);
            
            // Vertical kernel
            ctx.fillStyle = 'rgba(49, 130, 206, 0.1)';
            ctx.fillRect(margin, separatorY + 2*margin + kernelHeight, w - 2*margin, kernelHeight);
            
            // 1D vertical gaussian
            ctx.beginPath();
            ctx.moveTo(margin + (w - 2*margin)/2, separatorY + 2*margin + kernelHeight);
            
            for(let y = 0; y <= kernelHeight; y++) {
                const normalized = y / kernelHeight;
                const x = margin + (w - 2*margin)/2 - Math.exp(-Math.pow((normalized-0.5)*5, 2)) * (w - 2*margin)/4;
                ctx.lineTo(x, separatorY + 2*margin + kernelHeight + y);
            }
            
            ctx.strokeStyle = 'rgba(49, 130, 206, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Label for vertical
            ctx.font = '10px Arial';
            ctx.fillStyle = '#4a5568';
            ctx.textAlign = 'left';
            ctx.fillText('Kernel Gaussiano 1D (vertical)', margin + 5, separatorY + 2*margin + kernelHeight + 12);
            
            // Efficiency text
            ctx.font = 'bold 10px Arial';
            ctx.fillStyle = '#2c5282';
            ctx.textAlign = 'right';
            ctx.fillText('O(N²) operaciones', w - margin - 5, margin + 15);
            ctx.fillText('O(2N) operaciones', w - margin - 5, separatorY + margin + 12);
        }
    </script>
</body>
</html>" style="width:100%; height:100%; border:none;" sandbox="allow-scripts allow-same-origin allow-popups allow-forms allow-presentation"></iframe>
                    </section>
            </div>

            <div class="presentation-slide " id="export-slide-mb13xhbsh1gh3">
                <section class="slide" style="background: linear-gradient(to bottom right, #3B82F6, #1E40AF); color: #FFFFFF; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; box-sizing: border-box; padding: 0;">
                        <iframe srcdoc="<!DOCTYPE html>
<html lang=&quot;es&quot;>
<head>
    <meta charset=&quot;UTF-8&quot;>
    <meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;>
    <title>Aplicación: Extracción de Regiones con Filtrado Gaussiano</title>
    <link href=&quot;https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css&quot; rel=&quot;stylesheet&quot;>
    <link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css&quot;>
    <script src=&quot;https://cdn.jsdelivr.net/npm/chart.js&quot;></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f4f8;
            font-family: 'Arial', sans-serif;
        }
        .slide {
            width: 1280px;
            min-height: 720px;
            background: linear-gradient(135deg, #ffffff 0%, #f0f4f8 100%);
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        .title {
            font-weight: 700;
            color: #2c5282;
        }
        .content-box {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .process-step {
            position: relative;
            padding-left: 2.5rem;
        }
        .process-step:before {
            content: &quot;&quot;;
            position: absolute;
            left: 0.75rem;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #3182ce;
        }
        .process-step:last-child:before {
            height: 50%;
        }
        .step-number {
            position: absolute;
            left: 0;
            top: 0;
            width: 1.5rem;
            height: 1.5rem;
            background-color: #3182ce;
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.875rem;
            font-weight: bold;
        }
        .image-container {
            position: relative;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background-color: #000000;
            overflow: hidden;
        }
        .image-label {
            position: absolute;
            bottom: 0;
            left: 0;
            background-color: rgba(49, 130, 206, 0.8);
            color: white;
            padding: 2px 8px;
            border-radius: 0 4px 0 0;
            font-size: 0.75rem;
        }
        .parameter {
            display: inline-block;
            background-color: #ebf4ff;
            border-radius: 4px;
            padding: 2px 8px;
            margin: 0 2px;
            font-family: 'Courier New', monospace;
            color: #2c5282;
        }
        .highlight-box {
            border-left: 4px solid #3182ce;
            padding-left: 1rem;
            margin-left: -1rem;
        }
        .key-point {
            position: relative;
            padding-left: 20px;
        }
        .key-point:before {
            content: &quot;&quot;;
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            background-color: #3182ce;
            border-radius: 50%;
        }
        @keyframes pulseAnimation {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(1); opacity: 0.7; }
        }
        .pulse-animation {
            animation: pulseAnimation 2s infinite;
        }
        .region {
            position: absolute;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>
    <div class=&quot;slide flex flex-col p-10&quot;>
        <h1 class=&quot;title text-4xl mb-4 text-center&quot;>Aplicación: Extracción de Regiones con Filtrado Gaussiano</h1>
        <div class=&quot;w-20 h-1 bg-blue-600 rounded-full mb-6 mx-auto&quot;></div>
        
        <!-- Main grid layout -->
        <div class=&quot;grid grid-cols-2 gap-6&quot;>
            <!-- Left column - Process explanation -->
            <div class=&quot;content-box p-5 flex flex-col&quot;>
                <h2 class=&quot;text-xl text-blue-700 mb-4&quot;>Proceso de Extracción de Regiones</h2>
                
                <div class=&quot;space-y-6 flex-1&quot;>
                    <div class=&quot;process-step pt-1 pb-4&quot;>
                        <div class=&quot;step-number&quot;>1</div>
                        <h3 class=&quot;font-bold text-gray-800&quot;>Imagen Original</h3>
                        <p class=&quot;text-sm text-gray-600 mt-1&quot;>Imagen astronómica con regiones de interés (galaxias) y ruido de fondo.</p>
                    </div>
                    
                    <div class=&quot;process-step pt-1 pb-4&quot;>
                        <div class=&quot;step-number&quot;>2</div>
                        <h3 class=&quot;font-bold text-gray-800&quot;>Filtrado Paso Bajo</h3>
                        <p class=&quot;text-sm text-gray-600 mt-1&quot;>Aplicación de kernel gaussiano para suavizar la imagen:</p>
                        <div class=&quot;mt-2 highlight-box&quot;>
                            <p class=&quot;text-sm font-semibold&quot;>Parámetros del filtro:</p>
                            <ul class=&quot;text-sm text-gray-700 mt-1 list-disc list-inside&quot;>
                                <li>Tamaño: <span class=&quot;parameter&quot;>151×151</span> (~6% del ancho de imagen)</li>
                                <li>Desviación estándar: <span class=&quot;parameter&quot;>σ=25</span></li>
                                <li>Factor: <span class=&quot;parameter&quot;>K=1</span></li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class=&quot;process-step pt-1&quot;>
                        <div class=&quot;step-number&quot;>3</div>
                        <h3 class=&quot;font-bold text-gray-800&quot;>Umbralización</h3>
                        <p class=&quot;text-sm text-gray-600 mt-1&quot;>Aplicación de umbral para segmentar regiones:</p>
                        <div class=&quot;mt-2 highlight-box&quot;>
                            <p class=&quot;text-sm font-semibold&quot;>Criterio de umbral:</p>
                            <ul class=&quot;text-sm text-gray-700 mt-1 list-disc list-inside&quot;>
                                <li>Valor: <span class=&quot;parameter&quot;>T=0.4</span></li>
                                <li>Escalado de intensidades: <span class=&quot;parameter&quot;>[0,1]</span></li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <!-- Formula section -->
                <div class=&quot;mt-4 p-3 bg-blue-50 rounded-md&quot;>
                    <p class=&quot;text-sm font-semibold text-blue-700&quot;>Umbralización binaria:</p>
                    <div class=&quot;text-center mt-2&quot;>
                        <p class=&quot;text-sm&quot;>
                            g(x,y) = { 1 si f(x,y) ≥ T
                        </p>
                        <p class=&quot;text-sm&quot;>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 0 si f(x,y) < T
                        </p>
                    </div>
                </div>
                
            </div>
            
            <!-- Right column - Image processing visualization -->
            <div class=&quot;flex flex-col space-y-4&quot;>
                <!-- Example visualization -->
                <div class=&quot;content-box p-4 flex-1&quot;>
                    <h2 class=&quot;text-lg text-blue-700 mb-3&quot;>Ejemplo: Grupo Compacto de Hickson (Hubble)</h2>
                    
                    <div class=&quot;grid grid-cols-3 gap-3&quot;>
                        <!-- Original image -->
                        <div class=&quot;image-container flex justify-center items-center&quot; id=&quot;originalContainer&quot;>
                            <canvas id=&quot;originalImage&quot; width=&quot;120&quot; height=&quot;140&quot;></canvas>
                            <div class=&quot;image-label&quot;>Original</div>
                        </div>
                        
                        <!-- Filtered image -->
                        <div class=&quot;image-container flex justify-center items-center&quot; id=&quot;filteredContainer&quot;>
                            <canvas id=&quot;filteredImage&quot; width=&quot;120&quot; height=&quot;140&quot;></canvas>
                            <div class=&quot;image-label&quot;>Filtrado Gaussiano</div>
                        </div>
                        
                        <!-- Thresholded image -->
                        <div class=&quot;image-container flex justify-center items-center&quot; id=&quot;thresholdedContainer&quot;>
                            <canvas id=&quot;thresholdedImage&quot; width=&quot;120&quot; height=&quot;140&quot;></canvas>
                            <div class=&quot;image-label&quot;>Umbralizado</div>
                        </div>
                    </div>
                    
                    <!-- Interactive controls -->
                    <div class=&quot;mt-4 flex items-center&quot;>
                        <span class=&quot;text-sm text-gray-700 mr-3&quot;>σ:</span>
                        <input type=&quot;range&quot; id=&quot;sigmaSlider&quot; min=&quot;5&quot; max=&quot;50&quot; value=&quot;25&quot; class=&quot;flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer&quot;>
                        <span class=&quot;text-sm text-gray-700 ml-2 w-8&quot; id=&quot;sigmaValue&quot;>25</span>
                        
                        <span class=&quot;text-sm text-gray-700 ml-6 mr-3&quot;>T:</span>
                        <input type=&quot;range&quot; id=&quot;thresholdSlider&quot; min=&quot;0&quot; max=&quot;100&quot; value=&quot;40&quot; class=&quot;flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer&quot;>
                        <span class=&quot;text-sm text-gray-700 ml-2 w-8&quot; id=&quot;thresholdValue&quot;>0.4</span>
                    </div>
                </div>
                
                <!-- Key applications section -->
                <div class=&quot;content-box p-4 flex-1&quot;>
                    <h2 class=&quot;text-lg text-blue-700 mb-3&quot;>Aplicaciones de Extracción de Regiones</h2>
                    
                    <div class=&quot;grid grid-cols-2 gap-4 mt-2&quot;>
                        <div class=&quot;space-y-2&quot;>
                            <p class=&quot;key-point text-sm&quot;>Procesamiento de imágenes astronómicas</p>
                            <p class=&quot;key-point text-sm&quot;>Segmentación de objetos</p>
                            <p class=&quot;key-point text-sm&quot;>Detección de características</p>
                        </div>
                        
                        <div class=&quot;space-y-2&quot;>
                            <p class=&quot;key-point text-sm&quot;>Eliminación de detalles irrelevantes</p>
                            <p class=&quot;key-point text-sm&quot;>Análisis de objetos aislados</p>
                            <p class=&quot;key-point text-sm&quot;>Reducción de ruido</p>
                        </div>
                    </div>
                    
                    <div class=&quot;mt-4 p-3 bg-yellow-50 rounded-md&quot;>
                        <p class=&quot;text-sm text-gray-700&quot;>
                            <span class=&quot;font-semibold text-yellow-700&quot;>Nota importante:</span> 
                            La selección óptima del tamaño del kernel y umbral depende del tamaño característico de los objetos de interés y el nivel de detalles a preservar.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        window.onload = function() {
            // Simulate astronomical images
            const originalCtx = document.getElementById('originalImage').getContext('2d');
            const filteredCtx = document.getElementById('filteredImage').getContext('2d');
            const thresholdedCtx = document.getElementById('thresholdedImage').getContext('2d');
            
            const sigmaSlider = document.getElementById('sigmaSlider');
            const thresholdSlider = document.getElementById('thresholdSlider');
            const sigmaValue = document.getElementById('sigmaValue');
            const thresholdValue = document.getElementById('thresholdValue');

            // Star/galaxy positions and brightness
            const celestialObjects = [
                { x: 0.5, y: 0.3, size: 0.1, brightness: 1.0 },
                { x: 0.3, y: 0.5, size: 0.08, brightness: 0.8 },
                { x: 0.7, y: 0.7, size: 0.07, brightness: 0.7 },
                { x: 0.8, y: 0.2, size: 0.05, brightness: 0.9 },
                { x: 0.2, y: 0.8, size: 0.04, brightness: 0.6 }
            ];
            
            // Background stars (smaller)
            const backgroundStars = [];
            for (let i = 0; i < 100; i++) {
                backgroundStars.push({
                    x: Math.random(),
                    y: Math.random(),
                    size: Math.random() * 0.015 + 0.002,
                    brightness: Math.random() * 0.4 + 0.1
                });
            }
            
            function drawOriginalImage(ctx) {
                const w = ctx.canvas.width;
                const h = ctx.canvas.height;
                
                // Black background
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, w, h);
                
                // Draw background stars
                backgroundStars.forEach(star => {
                    const gradient = ctx.createRadialGradient(
                        star.x * w, star.y * h, 0,
                        star.x * w, star.y * h, star.size * w
                    );
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${star.brightness})`);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(star.x * w, star.y * h, star.size * w * 2, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw main celestial objects
                celestialObjects.forEach(obj => {
                    const gradient = ctx.createRadialGradient(
                        obj.x * w, obj.y * h, 0,
                        obj.x * w, obj.y * h, obj.size * w
                    );
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${obj.brightness})`);
                    gradient.addColorStop(0.7, `rgba(200, 220, 255, ${obj.brightness * 0.5})`);
                    gradient.addColorStop(1, 'rgba(200, 220, 255, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(obj.x * w, obj.y * h, obj.size * w * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add some diffraction spikes for the brighter objects
                    if (obj.brightness > 0.7) {
                        ctx.strokeStyle = `rgba(255, 255, 255, ${obj.brightness * 0.3})`;
                        ctx.lineWidth = 1;
                        
                        // Horizontal spike
                        ctx.beginPath();
                        ctx.moveTo(obj.x * w - obj.size * w * 4, obj.y * h);
                        ctx.lineTo(obj.x * w + obj.size * w * 4, obj.y * h);
                        ctx.stroke();
                        
                        // Vertical spike
                        ctx.beginPath();
                        ctx.moveTo(obj.x * w, obj.y * h - obj.size * w * 4);
                        ctx.lineTo(obj.x * w, obj.y * h + obj.size * w * 4);
                        ctx.stroke();
                    }
                });
            }
            
            function drawFilteredImage(ctx, sigma) {
                const w = ctx.canvas.width;
                const h = ctx.canvas.height;
                
                // Black background
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, w, h);
                
                // Normalize sigma to 0-1 scale
                const normalizedSigma = sigma / 50;
                const blurFactor = normalizedSigma * 15;
                
                // Draw blurred background stars (fewer of them)
                backgroundStars.filter(() => Math.random() > 0.7).forEach(star => {
                    const gradient = ctx.createRadialGradient(
                        star.x * w, star.y * h, 0,
                        star.x * w, star.y * h, star.size * w * (1 + blurFactor)
                    );
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${star.brightness * 0.8})`);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(star.x * w, star.y * h, star.size * w * 3 * (1 + blurFactor), 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw blurred main celestial objects
                celestialObjects.forEach(obj => {
                    const gradient = ctx.createRadialGradient(
                        obj.x * w, obj.y * h, 0,
                        obj.x * w, obj.y * h, obj.size * w * (1 + blurFactor)
                    );
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${obj.brightness * 0.9})`);
                    gradient.addColorStop(0.5, `rgba(200, 220, 255, ${obj.brightness * 0.5})`);
                    gradient.addColorStop(1, 'rgba(200, 220, 255, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(obj.x * w, obj.y * h, obj.size * w * 3 * (1 + blurFactor), 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            function drawThresholdedImage(ctx, threshold, sigma) {
                const w = ctx.canvas.width;
                const h = ctx.canvas.height;
                
                // Black background
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, w, h);
                
                // Normalize threshold to 0-1 scale
                const normalizedThreshold = threshold / 100;
                
                // Normalize sigma to 0-1 scale for size calculation
                const normalizedSigma = sigma / 50;
                const sizeFactor = 1 - normalizedSigma * 0.5; // Higher sigma = smaller thresholded regions
                
                // Draw thresholded regions (only those above threshold)
                ctx.fillStyle = '#ffffff';
                
                celestialObjects.forEach(obj => {
                    if (obj.brightness > normalizedThreshold) {
                        const effectiveSize = obj.size * w * 1.5 * sizeFactor;
                        
                        ctx.beginPath();
                        ctx.arc(obj.x * w, obj.y * h, effectiveSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }
            
            function addRegionIndicators() {
                // Add region indicators to the original container
                const container = document.getElementById('originalContainer');
                
                celestialObjects.forEach((obj, index) => {
                    if (index < 4) { // Just show for the 4 main objects
                        const region = document.createElement('div');
                        region.classList.add('region', 'pulse-animation');
                        region.style.left = `${obj.x * 100}%`;
                        region.style.top = `${obj.y * 100}%`;
                        region.style.width = `${obj.size * 100 * 4}px`;
                        region.style.height = `${obj.size * 100 * 4}px`;
                        region.style.marginLeft = `-${obj.size * 100 * 2}px`;
                        region.style.marginTop = `-${obj.size * 100 * 2}px`;
                        container.appendChild(region);
                    }
                });
            }
            
            function updateImages() {
                const sigma = parseInt(sigmaSlider.value);
                const threshold = parseInt(thresholdSlider.value);
                
                sigmaValue.textContent = sigma;
                thresholdValue.textContent = (threshold / 100).toFixed(1);
                
                drawOriginalImage(originalCtx);
                drawFilteredImage(filteredCtx, sigma);
                drawThresholdedImage(thresholdedCtx, threshold, sigma);
            }
            
            sigmaSlider.addEventListener('input', updateImages);
            thresholdSlider.addEventListener('input', updateImages);
            
            updateImages();
            addRegionIndicators();
        };
    </script>
</body>
</html>" style="width:100%; height:100%; border:none;" sandbox="allow-scripts allow-same-origin allow-popups allow-forms allow-presentation"></iframe>
                    </section>
            </div>

            <div class="presentation-slide " id="export-slide-mb13xtz8y7zja">
                <section class="slide" style="background: linear-gradient(to bottom right, #3B82F6, #1E40AF); color: #FFFFFF; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; box-sizing: border-box; padding: 0;">
                        <iframe srcdoc="<!DOCTYPE html>
<html lang=&quot;es&quot;>
<head>
    <meta charset=&quot;UTF-8&quot;>
    <meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;>
    <title>Aplicación: Corrección de Sombreado usando Filtrado Paso Bajo</title>
    <link href=&quot;https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css&quot; rel=&quot;stylesheet&quot;>
    <link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css&quot;>
    <script src=&quot;https://cdn.jsdelivr.net/npm/chart.js&quot;></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f4f8;
            font-family: 'Arial', sans-serif;
        }
        .slide {
            width: 1280px;
            min-height: 720px;
            background: linear-gradient(135deg, #ffffff 0%, #f0f4f8 100%);
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        .title {
            font-weight: 700;
            color: #2c5282;
        }
        .content-box {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .image-container {
            position: relative;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background-color: #f8fafc;
            overflow: hidden;
        }
        .image-label {
            position: absolute;
            bottom: 0;
            left: 0;
            background-color: rgba(49, 130, 206, 0.8);
            color: white;
            padding: 2px 8px;
            border-radius: 0 4px 0 0;
            font-size: 0.75rem;
        }
        .key-point {
            position: relative;
            padding-left: 20px;
        }
        .key-point:before {
            content: &quot;&quot;;
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            background-color: #3182ce;
            border-radius: 50%;
        }
        .formula {
            background-color: rgba(237, 242, 247, 0.8);
            border-radius: 4px;
            padding: 4px 8px;
            display: inline-block;
            font-family: 'Times New Roman', serif;
            font-style: italic;
        }
        .process-step {
            position: relative;
            padding-left: 40px;
        }
        .step-number {
            position: absolute;
            left: 0;
            top: 0;
            width: 28px;
            height: 28px;
            background-color: #3182ce;
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1rem;
            font-weight: bold;
        }
        .arrow-diagram {
            position: relative;
            height: 50px;
        }
        .arrow-line {
            position: absolute;
            top: 50%;
            left: 10%;
            right: 10%;
            height: 4px;
            background-color: #3182ce;
            transform: translateY(-50%);
        }
        .arrow-point {
            position: absolute;
            top: 50%;
            right: 10%;
            width: 0; 
            height: 0;
            transform: translateY(-50%);
            border-left: 12px solid #3182ce;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
        }
        .operation-symbol {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            background-color: white;
            border: 2px solid #3182ce;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: #3182ce;
        }
        .parameter {
            display: inline-block;
            background-color: #ebf4ff;
            border-radius: 4px;
            padding: 2px 8px;
            margin: 0 2px;
            font-family: 'Courier New', monospace;
            color: #2c5282;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .fade-in {
            animation: fadeIn 0.6s ease-out;
        }
    </style>
</head>
<body>
    <div class=&quot;slide flex flex-col p-10&quot;>
        <h1 class=&quot;title text-4xl mb-4 text-center&quot;>Aplicación: Corrección de Sombreado usando Filtrado Paso Bajo</h1>
        <div class=&quot;w-20 h-1 bg-blue-600 rounded-full mb-6 mx-auto&quot;></div>
        
        <!-- Main grid layout -->
        <div class=&quot;grid grid-cols-2 gap-6&quot;>
            <!-- Left column - Theoretical explanation -->
            <div class=&quot;content-box p-6&quot;>
                <h2 class=&quot;text-xl text-blue-700 mb-4&quot;>¿Qué es la Corrección de Sombreado?</h2>
                
                <div class=&quot;mb-6&quot;>
                    <p class=&quot;text-gray-700&quot;>También llamada <span class=&quot;italic&quot;>flat-field correction</span>, corrige la iluminación no uniforme en imágenes.</p>
                    
                    <div class=&quot;mt-4 space-y-3&quot;>
                        <p class=&quot;key-point text-gray-700&quot;>Elimina variaciones de intensidad causadas por iluminación desigual</p>
                        <p class=&quot;key-point text-gray-700&quot;>Mejora la precisión de mediciones y segmentación</p>
                        <p class=&quot;key-point text-gray-700&quot;>Facilita la interpretación visual y procesamiento automático</p>
                    </div>
                </div>
                
                <div class=&quot;bg-blue-50 p-4 rounded-lg&quot;>
                    <h3 class=&quot;text-blue-700 font-semibold mb-2&quot;>Proceso de Corrección</h3>
                    
                    <div class=&quot;process-step py-2&quot;>
                        <div class=&quot;step-number&quot;>1</div>
                        <p class=&quot;font-semibold&quot;>Estimar el patrón de sombreado</p>
                        <p class=&quot;text-sm text-gray-600 mt-1&quot;>Aplicar filtro paso bajo con kernel gaussiano para extraer la componente de iluminación.</p>
                    </div>
                    
                    <div class=&quot;process-step py-2&quot;>
                        <div class=&quot;step-number&quot;>2</div>
                        <p class=&quot;font-semibold&quot;>División por el patrón estimado</p>
                        <p class=&quot;text-sm text-gray-600 mt-1&quot;>Normalizar la imagen dividiendo píxel por píxel por el patrón de iluminación.</p>
                    </div>
                    
                    <div class=&quot;mt-4&quot;>
                        <p class=&quot;text-sm font-semibold text-blue-700&quot;>Fórmula de corrección:</p>
                        <div class=&quot;text-center mt-2&quot;>
                            <p class=&quot;formula&quot;>g(x,y) = f(x,y) / s(x,y)</p>
                            <p class=&quot;text-xs text-gray-600 mt-1&quot;>donde f es la imagen original, s es el patrón de sombreado, y g es la imagen corregida</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right column - Example visualization -->
            <div class=&quot;content-box p-6 flex flex-col&quot;>
                <h2 class=&quot;text-xl text-blue-700 mb-4&quot;>Ejemplo: Corrección de Tablero de Ajedrez</h2>
                
                <div class=&quot;flex-1 flex flex-col&quot;>
                    <!-- Images row -->
                    <div class=&quot;grid grid-cols-3 gap-4 mb-5&quot;>
                        <div class=&quot;image-container h-40&quot; id=&quot;shadedContainer&quot;>
                            <canvas id=&quot;shadedImage&quot; width=&quot;140&quot; height=&quot;140&quot;></canvas>
                            <div class=&quot;image-label&quot;>Imagen con Sombreado</div>
                        </div>
                        
                        <div class=&quot;image-container h-40&quot; id=&quot;patternContainer&quot;>
                            <canvas id=&quot;patternImage&quot; width=&quot;140&quot; height=&quot;140&quot;></canvas>
                            <div class=&quot;image-label&quot;>Patrón Estimado</div>
                        </div>
                        
                        <div class=&quot;image-container h-40&quot; id=&quot;correctedContainer&quot;>
                            <canvas id=&quot;correctedImage&quot; width=&quot;140&quot; height=&quot;140&quot;></canvas>
                            <div class=&quot;image-label&quot;>Imagen Corregida</div>
                        </div>
                    </div>
                    
                    <!-- Process visualization -->
                    <div class=&quot;arrow-diagram my-2&quot;>
                        <div class=&quot;arrow-line&quot;></div>
                        <div class=&quot;arrow-point&quot;></div>
                        <div class=&quot;operation-symbol&quot;>÷</div>
                    </div>
                    
                    <!-- Parameters -->
                    <div class=&quot;bg-gray-50 p-4 rounded-lg&quot;>
                        <h3 class=&quot;font-semibold text-gray-700 mb-2&quot;>Parámetros del Ejemplo</h3>
                        <ul class=&quot;space-y-2 text-sm&quot;>
                            <li><span class=&quot;font-semibold&quot;>Imagen:</span> Tablero de ajedrez 2048×2048 píxeles con cuadros de 128×128</li>
                            <li><span class=&quot;font-semibold&quot;>Sombreado:</span> Gradiente diagonal en dirección -45°</li>
                            <li><span class=&quot;font-semibold&quot;>Kernel:</span> Gaussiano de tamaño <span class=&quot;parameter&quot;>512×512</span> (4 veces el tamaño de los cuadros)</li>
                            <li><span class=&quot;font-semibold&quot;>Parámetros:</span> <span class=&quot;parameter&quot;>K=1</span>, <span class=&quot;parameter&quot;>σ=128</span> (igual al tamaño de los cuadros)</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Bottom section - Computational advantage -->
        <div class=&quot;content-box p-6 mt-6&quot;>
            <h2 class=&quot;text-xl text-blue-700 mb-3&quot;>Ventaja Computacional de Kernels Separables</h2>
            
            <div class=&quot;flex items-center&quot;>
                <div class=&quot;w-1/3&quot;>
                    <canvas id=&quot;performanceChart&quot; width=&quot;300&quot; height=&quot;180&quot;></canvas>
                </div>
                
                <div class=&quot;w-2/3 pl-8&quot;>
                    <div class=&quot;grid grid-cols-2 gap-4&quot;>
                        <div>
                            <p class=&quot;key-point font-semibold&quot;>Kernel 2D directo: 2.2 horas</p>
                            <p class=&quot;key-point font-semibold&quot;>Kernel separable: 30 segundos</p>
                            <p class=&quot;key-point font-semibold&quot;>Ventaja para kernel 512×512: 262:1</p>
                        </div>
                        
                        <div class=&quot;bg-blue-50 p-3 rounded-lg&quot;>
                            <p class=&quot;text-sm text-gray-700&quot;>
                                Para implementaciones reales, es crucial usar kernels separables cuando se trabaja con kernels grandes. Sin esta optimización, la corrección de sombreado en imágenes de alta resolución sería computacionalmente inviable.
                            </p>
                        </div>
                    </div>
                    
                    <div class=&quot;mt-4 text-center&quot;>
                        <p class=&quot;formula text-sm&quot;>Complejidad kernel 2D: O(N²) → Kernel separable: O(2N)</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        window.onload = function() {
            // Draw shaded checkerboard
            const shadedCtx = document.getElementById('shadedImage').getContext('2d');
            drawShadedCheckerboard(shadedCtx);
            
            // Draw shading pattern
            const patternCtx = document.getElementById('patternImage').getContext('2d');
            drawShadingPattern(patternCtx);
            
            // Draw corrected image
            const correctedCtx = document.getElementById('correctedImage').getContext('2d');
            drawCorrectedCheckerboard(correctedCtx);
            
            // Performance comparison chart
            const perfCtx = document.getElementById('performanceChart').getContext('2d');
            createPerformanceChart(perfCtx);
        };
        
        function drawShadedCheckerboard(ctx) {
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;
            const squareSize = Math.floor(w / 8);
            
            // Draw checkerboard pattern with shading
            for(let x = 0; x < 8; x++) {
                for(let y = 0; y < 8; y++) {
                    // Base color: white or black
                    let color = (x + y) % 2 === 0 ? 255 : 0;
                    
                    // Apply shading - darker toward bottom-right
                    const shadingFactor = 0.3 + 0.7 * ((x + y) / 14); // 0.3 to 1.0
                    
                    // Calculate final color with shading
                    const finalColor = Math.floor(color * shadingFactor);
                    
                    ctx.fillStyle = `rgb(${finalColor}, ${finalColor}, ${finalColor})`;
                    ctx.fillRect(x * squareSize, y * squareSize, squareSize, squareSize);
                }
            }
        }
        
        function drawShadingPattern(ctx) {
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;
            
            // Create diagonal gradient (bottom-left to top-right)
            const gradient = ctx.createLinearGradient(0, h, w, 0);
            gradient.addColorStop(0, 'rgba(40, 40, 40, 1)');
            gradient.addColorStop(1, 'rgba(220, 220, 220, 1)');
            
            // Draw gradient
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, w, h);
        }
        
        function drawCorrectedCheckerboard(ctx) {
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;
            const squareSize = Math.floor(w / 8);
            
            // Draw pure checkerboard pattern (corrected)
            for(let x = 0; x < 8; x++) {
                for(let y = 0; y < 8; y++) {
                    ctx.fillStyle = (x + y) % 2 === 0 ? '#ffffff' : '#000000';
                    ctx.fillRect(x * squareSize, y * squareSize, squareSize, squareSize);
                }
            }
        }
        
        function createPerformanceChart(ctx) {
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Kernel 2D', 'Kernel Separable'],
                    datasets: [{
                        label: 'Tiempo de procesamiento relativo',
                        data: [262, 1],
                        backgroundColor: [
                            'rgba(255, 99, 132, 0.7)',
                            'rgba(54, 162, 235, 0.7)'
                        ],
                        borderColor: [
                            'rgb(255, 99, 132)',
                            'rgb(54, 162, 235)'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Tiempo relativo (escala log)'
                            },
                            type: 'logarithmic'
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Comparación de Rendimiento'
                        },
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }
        
        // Add fade-in animation to containers
        setTimeout(() => {
            document.getElementById('shadedContainer').classList.add('fade-in');
            
            setTimeout(() => {
                document.getElementById('patternContainer').classList.add('fade-in');
                
                setTimeout(() => {
                    document.getElementById('correctedContainer').classList.add('fade-in');
                }, 400);
            }, 400);
        }, 300);
    </script>
</body>
</html>" style="width:100%; height:100%; border:none;" sandbox="allow-scripts allow-same-origin allow-popups allow-forms allow-presentation"></iframe>
                    </section>
            </div>

            <div class="presentation-slide " id="export-slide-mb13ylcqjr5pq">
                <section class="slide" style="background: linear-gradient(to bottom right, #3B82F6, #1E40AF); color: #FFFFFF; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; box-sizing: border-box; padding: 0;">
                        <iframe srcdoc="<!DOCTYPE html>
<html lang=&quot;es&quot;>
<head>
    <meta charset=&quot;UTF-8&quot;>
    <meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;>
    <title>Relación entre Tamaño de Imagen y Kernel</title>
    <link href=&quot;https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css&quot; rel=&quot;stylesheet&quot;>
    <link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css&quot;>
    <script src=&quot;https://cdn.jsdelivr.net/npm/chart.js&quot;></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f4f8;
            font-family: 'Arial', sans-serif;
        }
        .slide {
            width: 1280px;
            min-height: 720px;
            background: linear-gradient(135deg, #ffffff 0%, #f0f4f8 100%);
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        .title {
            font-weight: 700;
            color: #2c5282;
        }
        .content-box {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .key-point {
            position: relative;
            padding-left: 20px;
        }
        .key-point:before {
            content: &quot;&quot;;
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            background-color: #3182ce;
            border-radius: 50%;
        }
        .parameter {
            display: inline-block;
            background-color: #ebf4ff;
            border-radius: 4px;
            padding: 2px 8px;
            margin: 0 2px;
            font-family: 'Courier New', monospace;
            color: #2c5282;
        }
        .image-container {
            position: relative;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background-color: #f8fafc;
            overflow: hidden;
        }
        .image-label {
            position: absolute;
            bottom: 0;
            left: 0;
            background-color: rgba(49, 130, 206, 0.8);
            color: white;
            padding: 2px 8px;
            border-radius: 0 4px 0 0;
            font-size: 0.75rem;
        }
        .formula-box {
            background-color: rgba(237, 242, 247, 0.8);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            font-family: 'Times New Roman', serif;
        }
        .arrow {
            position: absolute;
            width: 120px;
            height: 30px;
        }
        .arrow:before {
            content: &quot;&quot;;
            position: absolute;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            border-left: 15px solid #3182ce;
        }
        .arrow:after {
            content: &quot;&quot;;
            position: absolute;
            top: 50%;
            left: 0;
            right: 15px;
            transform: translateY(-50%);
            height: 4px;
            background-color: #3182ce;
        }
        .scale-label {
            font-size: 0.7rem;
            color: #4a5568;
            text-align: center;
            position: absolute;
            width: 100%;
        }
        .highlight-effect {
            transition: all 0.3s ease;
        }
        .highlight-effect:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .pulse {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div class=&quot;slide flex flex-col p-10&quot;>
        <h1 class=&quot;title text-4xl mb-4 text-center&quot;>Relación entre Tamaño de Imagen y Kernel</h1>
        <div class=&quot;w-20 h-1 bg-blue-600 rounded-full mb-6 mx-auto&quot;></div>
        
        <!-- Main content grid -->
        <div class=&quot;grid grid-cols-5 gap-6 mb-6&quot;>
            <!-- Left column: Concept explanation -->
            <div class=&quot;content-box p-5 col-span-2&quot;>
                <h2 class=&quot;text-xl text-blue-700 mb-4&quot;>Principio Fundamental</h2>
                
                <div class=&quot;space-y-4 mb-6&quot;>
                    <p class=&quot;key-point font-semibold&quot;>El nivel de desenfoque depende directamente del tamaño relativo kernel/imagen</p>
                    <p class=&quot;key-point font-semibold&quot;>Aumentar dimensiones de imagen = Menos desenfoque con mismo kernel</p>
                    <p class=&quot;key-point font-semibold&quot;>Para mantener efecto visual consistente: escalar kernel y σ proporcionalmente</p>
                </div>
                
                <div class=&quot;bg-yellow-50 p-4 rounded-lg mb-5&quot;>
                    <h3 class=&quot;font-semibold text-yellow-700&quot;>Regla de Escalado</h3>
                    <p class=&quot;text-sm mt-2&quot;>Si la imagen aumenta por un factor <span class=&quot;font-bold&quot;>k</span>, para mantener la misma apariencia visual:</p>
                    <ul class=&quot;text-sm list-disc list-inside mt-1&quot;>
                        <li>Tamaño de kernel: multiplicar por <span class=&quot;font-bold&quot;>k</span></li>
                        <li>Valor de σ: multiplicar por <span class=&quot;font-bold&quot;>k</span></li>
                    </ul>
                </div>
                
                <div class=&quot;formula-box&quot;>
                    <p class=&quot;text-lg font-semibold&quot;>Para imagen de factor k:</p>
                    <p class=&quot;text-xl mt-2&quot;>Kernel<sub>nuevo</sub> = k × Kernel<sub>original</sub></p>
                    <p class=&quot;text-xl mt-1&quot;>σ<sub>nuevo</sub> = k × σ<sub>original</sub></p>
                </div>
            </div>
            
            <!-- Center and right: Visual comparison -->
            <div class=&quot;content-box p-5 col-span-3 relative&quot;>
                <h2 class=&quot;text-xl text-blue-700 mb-4&quot;>Demostración Visual</h2>
                
                <div class=&quot;grid grid-cols-3 gap-4 mb-6&quot;>
                    <!-- Original test pattern -->
                    <div class=&quot;image-container highlight-effect&quot; id=&quot;patternContainer&quot;>
                        <canvas id=&quot;testPattern&quot; width=&quot;130&quot; height=&quot;130&quot;></canvas>
                        <div class=&quot;image-label&quot;>Patrón Original</div>
                    </div>
                    
                    <!-- Small image with filter -->
                    <div class=&quot;image-container highlight-effect&quot; id=&quot;smallFilteredContainer&quot;>
                        <canvas id=&quot;smallFiltered&quot; width=&quot;130&quot; height=&quot;130&quot;></canvas>
                        <div class=&quot;image-label&quot;>1024×1024, σ=31</div>
                    </div>
                    
                    <!-- Large image with same filter -->
                    <div class=&quot;image-container highlight-effect&quot; id=&quot;largeFilteredContainer&quot;>
                        <canvas id=&quot;largeFiltered&quot; width=&quot;130&quot; height=&quot;130&quot;></canvas>
                        <div class=&quot;image-label&quot;>4096×4096, σ=31</div>
                    </div>
                </div>
                
                <!-- Scale comparison diagram -->
                <div class=&quot;mb-6 flex items-center justify-center&quot;>
                    <!-- Scale indicator -->
                    <div class=&quot;relative w-full h-12&quot;>
                        <div class=&quot;absolute left-1/6 transform -translate-x-1/2 top-0&quot;>
                            <div class=&quot;w-2 h-8 bg-blue-600&quot;></div>
                            <span class=&quot;scale-label&quot;>1x</span>
                        </div>
                        
                        <div class=&quot;absolute left-1/2 transform -translate-x-1/2 top-0&quot;>
                            <div class=&quot;w-2 h-8 bg-blue-600&quot;></div>
                            <span class=&quot;scale-label&quot;>2x</span>
                        </div>
                        
                        <div class=&quot;absolute right-1/6 transform translate-x-1/2 top-0&quot;>
                            <div class=&quot;w-2 h-8 bg-blue-600&quot;></div>
                            <span class=&quot;scale-label&quot;>4x</span>
                        </div>
                        
                        <div class=&quot;absolute left-0 right-0 top-4 h-1 bg-blue-300&quot;></div>
                    </div>
                </div>
                
                <!-- Interactive controls -->
                <div class=&quot;flex flex-col&quot;>
                    <div class=&quot;flex items-center justify-between mb-2&quot;>
                        <span class=&quot;w-24 text-sm text-gray-700&quot;>Tamaño imagen:</span>
                        <input type=&quot;range&quot; id=&quot;sizeSlider&quot; min=&quot;1&quot; max=&quot;4&quot; step=&quot;1&quot; value=&quot;1&quot; class=&quot;flex-1 h-2 mx-4 bg-gray-200 rounded-lg appearance-none cursor-pointer&quot;>
                        <span class=&quot;text-sm text-gray-700 w-28&quot; id=&quot;sizeValue&quot;>1024×1024</span>
                    </div>
                    
                    <div class=&quot;flex items-center justify-between&quot;>
                        <span class=&quot;w-24 text-sm text-gray-700&quot;>Tamaño kernel:</span>
                        <input type=&quot;range&quot; id=&quot;kernelSlider&quot; min=&quot;1&quot; max=&quot;4&quot; step=&quot;1&quot; value=&quot;1&quot; class=&quot;flex-1 h-2 mx-4 bg-gray-200 rounded-lg appearance-none cursor-pointer&quot;>
                        <span class=&quot;text-sm text-gray-700 w-28&quot; id=&quot;kernelValue&quot;>187×187</span>
                    </div>
                </div>
                
                <!-- Conclusion box -->
                <div class=&quot;bg-blue-50 mt-4 p-3 rounded-lg&quot;>
                    <p class=&quot;text-sm&quot;>
                        <span class=&quot;font-bold text-blue-700&quot;>Conclusión:</span> 
                        La manera en que percibimos el desenfoque depende de la relación entre el tamaño del kernel y la dimensión de los objetos en la imagen, no del tamaño absoluto.
                    </p>
                </div>
                
                <!-- Arrow indicators -->
                <div class=&quot;arrow&quot; style=&quot;top: 85px; left: 140px; transform: rotate(0deg);&quot;></div>
                <div class=&quot;arrow&quot; style=&quot;top: 85px; right: 140px; transform: rotate(180deg);&quot;></div>
            </div>
        </div>
        
        <!-- Bottom section: Performance chart -->
        <div class=&quot;content-box p-5 mx-auto&quot; style=&quot;width: 85%;&quot;>
            <div class=&quot;flex items-center&quot;>
                <div class=&quot;w-2/3&quot;>
                    <h2 class=&quot;text-lg text-blue-700 mb-3&quot;>Efecto del Tamaño de Imagen en el Rendimiento</h2>
                    <div class=&quot;grid grid-cols-2 gap-4&quot;>
                        <div>
                            <div class=&quot;key-point&quot;>Costo computacional: O(m×n×w×h)</div>
                            <div class=&quot;key-point&quot;>4× imagen = 16× tiempo de procesamiento</div>
                            <div class=&quot;key-point&quot;>Kernel separable: vital para imágenes grandes</div>
                        </div>
                        <div>
                            <div class=&quot;pulse bg-blue-50 p-3 rounded-lg&quot;>
                                <p class=&quot;text-sm font-semibold text-blue-700 mb-1&quot;>Error común:</p>
                                <p class=&quot;text-sm&quot;>No ajustar parámetros del kernel proporcionalmente al cambiar dimensiones de la imagen.</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class=&quot;w-1/3&quot;>
                    <canvas id=&quot;performanceChart&quot; width=&quot;280&quot; height=&quot;160&quot;></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        window.onload = function() {
            // Draw test pattern and filtered versions
            drawTestPattern();
            drawFilteredVersions();
            
            // Set up performance chart
            createPerformanceChart();
            
            // Set up slider interactions
            document.getElementById('sizeSlider').addEventListener('input', updateValues);
            document.getElementById('kernelSlider').addEventListener('input', updateValues);
            updateValues();
        };
        
        function drawTestPattern() {
            const ctx = document.getElementById('testPattern').getContext('2d');
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;
            
            // White background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, w, h);
            
            // Draw a simplified version of the test pattern
            
            // Draw large 'a' in center
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('a', w/2, h/2);
            
            // Draw grid pattern in top-left
            const gridSize = 10;
            for (let x = 0; x < 4; x++) {
                for (let y = 0; y < 4; y++) {
                    if ((x + y) % 2 === 0) {
                        ctx.fillRect(5 + x*gridSize, 5 + y*gridSize, gridSize, gridSize);
                    }
                }
            }
            
            // Draw circles
            ctx.beginPath();
            ctx.arc(w/4, 3*h/4, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw lines
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(w/2 - 30, h/4 - 10 + i*7);
                ctx.lineTo(w/2 + 30, h/4 - 10 + i*7);
                ctx.stroke();
            }
            
            // Draw small 'a' characters at bottom
            ctx.font = '16px Arial';
            for (let i = 0; i < 6; i++) {
                ctx.fillText('a', 20 + i*20, h - 15);
            }
        }
        
        function drawFilteredVersions() {
            // Draw small filtered image (more blurred)
            const ctx1 = document.getElementById('smallFiltered').getContext('2d');
            const w1 = ctx1.canvas.width;
            const h1 = ctx1.canvas.height;
            
            // Apply gaussian blur effect (simulated)
            ctx1.filter = 'blur(4px)';
            
            // Draw the same pattern but blurred
            ctx1.fillStyle = '#ffffff';
            ctx1.fillRect(0, 0, w1, h1);
            
            // Draw large 'a' in center (blurred)
            ctx1.fillStyle = '#000000';
            ctx1.font = 'bold 40px Arial';
            ctx1.textAlign = 'center';
            ctx1.textBaseline = 'middle';
            ctx1.fillText('a', w1/2, h1/2);
            
            // Draw grid pattern in top-left (blurred)
            const gridSize1 = 10;
            for (let x = 0; x < 4; x++) {
                for (let y = 0; y < 4; y++) {
                    if ((x + y) % 2 === 0) {
                        ctx1.fillRect(5 + x*gridSize1, 5 + y*gridSize1, gridSize1, gridSize1);
                    }
                }
            }
            
            // Draw circles (blurred)
            ctx1.beginPath();
            ctx1.arc(w1/4, 3*h1/4, 10, 0, Math.PI * 2);
            ctx1.fill();
            
            // Draw lines (blurred)
            ctx1.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                ctx1.beginPath();
                ctx1.moveTo(w1/2 - 30, h1/4 - 10 + i*7);
                ctx1.lineTo(w1/2 + 30, h1/4 - 10 + i*7);
                ctx1.stroke();
            }
            
            // Draw small 'a' characters at bottom (blurred)
            ctx1.font = '16px Arial';
            for (let i = 0; i < 6; i++) {
                ctx1.fillText('a', 20 + i*20, h1 - 15);
            }
            
            // Reset filter
            ctx1.filter = 'none';
            
            // Draw large filtered image (less blurred with same kernel)
            const ctx2 = document.getElementById('largeFiltered').getContext('2d');
            const w2 = ctx2.canvas.width;
            const h2 = ctx2.canvas.height;
            
            // Apply less gaussian blur effect (simulated)
            ctx2.filter = 'blur(1px)';
            
            // Draw the same pattern but less blurred
            ctx2.fillStyle = '#ffffff';
            ctx2.fillRect(0, 0, w2, h2);
            
            // Draw large 'a' in center (less blurred)
            ctx2.fillStyle = '#000000';
            ctx2.font = 'bold 40px Arial';
            ctx2.textAlign = 'center';
            ctx2.textBaseline = 'middle';
            ctx2.fillText('a', w2/2, h2/2);
            
            // Draw grid pattern in top-left (less blurred)
            const gridSize2 = 10;
            for (let x = 0; x < 4; x++) {
                for (let y = 0; y < 4; y++) {
                    if ((x + y) % 2 === 0) {
                        ctx2.fillRect(5 + x*gridSize2, 5 + y*gridSize2, gridSize2, gridSize2);
                    }
                }
            }
            
            // Draw circles (less blurred)
            ctx2.beginPath();
            ctx2.arc(w2/4, 3*h2/4, 10, 0, Math.PI * 2);
            ctx2.fill();
            
            // Draw lines (less blurred)
            ctx2.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                ctx2.beginPath();
                ctx2.moveTo(w2/2 - 30, h2/4 - 10 + i*7);
                ctx2.lineTo(w2/2 + 30, h2/4 - 10 + i*7);
                ctx2.stroke();
            }
            
            // Draw small 'a' characters at bottom (less blurred)
            ctx2.font = '16px Arial';
            for (let i = 0; i < 6; i++) {
                ctx2.fillText('a', 20 + i*20, h2 - 15);
            }
            
            // Reset filter
            ctx2.filter = 'none';
        }
        
        function createPerformanceChart() {
            const ctx = document.getElementById('performanceChart').getContext('2d');
            
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['1024²', '2048²', '4096²'],
                    datasets: [{
                        label: 'Tiempo de procesamiento',
                        data: [1, 4, 16],
                        backgroundColor: [
                            'rgba(54, 162, 235, 0.7)',
                            'rgba(75, 192, 192, 0.7)',
                            'rgba(255, 99, 132, 0.7)'
                        ],
                        borderColor: [
                            'rgb(54, 162, 235)',
                            'rgb(75, 192, 192)',
                            'rgb(255, 99, 132)'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Tiempo relativo'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Tamaño de imagen'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: 'Escalado de Tiempo de Procesamiento'
                        }
                    }
                }
            });
        }
        
        function updateValues() {
            const sizeSlider = document.getElementById('sizeSlider');
            const kernelSlider = document.getElementById('kernelSlider');
            const sizeValue = document.getElementById('sizeValue');
            const kernelValue = document.getElementById('kernelValue');
            
            // Base size value
            const baseSize = 1024;
            const baseKernel = 187;
            
            // Calculate new values
            const sizeFactor = parseInt(sizeSlider.value);
            const kernelFactor = parseInt(kernelSlider.value);
            
            // Update displayed values
            const newSize = baseSize * sizeFactor;
            const newKernel = baseKernel * kernelFactor;
            
            sizeValue.textContent = `${newSize}×${newSize}`;
            kernelValue.textContent = `${newKernel}×${newKernel}`;
            
            // Simulate blur effect based on kernel/image size ratio
            const blurRatio = kernelFactor / sizeFactor;
            
            // Update visual appearance of filtered images
            const smallCanvas = document.getElementById('smallFiltered');
            const largeCanvas = document.getElementById('largeFiltered');
            const smallCtx = smallCanvas.getContext('2d');
            const largeCtx = largeCanvas.getContext('2d');
            
            // Clear canvases
            smallCtx.clearRect(0, 0, smallCanvas.width, smallCanvas.height);
            largeCtx.clearRect(0, 0, largeCanvas.width, largeCanvas.height);
            
            // Apply simulated blur
            smallCtx.filter = `blur(${4 * blurRatio}px)`;
            largeCtx.filter = `blur(${blurRatio}px)`;
            
            // Redraw patterns with new blur settings
            drawFilteredPattern(smallCtx);
            drawFilteredPattern(largeCtx);
            
            // Update labels
            document.querySelector('#smallFilteredContainer .image-label').textContent = 
                `1024×1024, σ=${Math.round(31 * kernelFactor)}`;
            
            document.querySelector('#largeFilteredContainer .image-label').textContent = 
                `${newSize}×${newSize}, σ=${Math.round(31 * kernelFactor)}`;
        }
        
        function drawFilteredPattern(ctx) {
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;
            
            // Draw the pattern
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, w, h);
            
            // Draw large 'a' in center
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('a', w/2, h/2);
            
            // Draw grid pattern in top-left
            const gridSize = 10;
            for (let x = 0; x < 4; x++) {
                for (let y = 0; y < 4; y++) {
                    if ((x + y) % 2 === 0) {
                        ctx.fillRect(5 + x*gridSize, 5 + y*gridSize, gridSize, gridSize);
                    }
                }
            }
            
            // Draw circles
            ctx.beginPath();
            ctx.arc(w/4, 3*h/4, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw lines
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(w/2 - 30, h/4 - 10 + i*7);
                ctx.lineTo(w/2 + 30, h/4 - 10 + i*7);
                ctx.stroke();
            }
            
            // Draw small 'a' characters at bottom
            ctx.font = '16px Arial';
            for (let i = 0; i < 6; i++) {
                ctx.fillText('a', 20 + i*20, h - 15);
            }
            
            // Reset filter
            ctx.filter = 'none';
        }
    </script>
</body>
</html>" style="width:100%; height:100%; border:none;" sandbox="allow-scripts allow-same-origin allow-popups allow-forms allow-presentation"></iframe>
                    </section>
            </div>

            <div class="presentation-slide " id="export-slide-mb13z0lfjl1rd">
                <section class="slide" style="background: linear-gradient(to bottom right, #3B82F6, #1E40AF); color: #FFFFFF; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; box-sizing: border-box; padding: 0;">
                        <iframe srcdoc="<!DOCTYPE html>
<html lang=&quot;es&quot;>
<head>
    <meta charset=&quot;UTF-8&quot;>
    <meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;>
    <title>Conclusiones y Referencias</title>
    <link href=&quot;https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css&quot; rel=&quot;stylesheet&quot;>
    <link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css&quot;>
    <script src=&quot;https://cdn.jsdelivr.net/npm/chart.js&quot;></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f4f8;
            font-family: 'Arial', sans-serif;
        }
        .slide {
            width: 1280px;
            min-height: 720px;
            background: linear-gradient(135deg, #ffffff 0%, #f0f4f8 100%);
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        .title {
            font-weight: 700;
            color: #2c5282;
        }
        .content-box {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
        }
        .content-box:hover {
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .key-point {
            position: relative;
            padding-left: 24px;
            margin-bottom: 12px;
        }
        .key-point:before {
            content: &quot;&quot;;
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 10px;
            height: 10px;
            background-color: #3182ce;
            border-radius: 50%;
        }
        .concept-item {
            transition: transform 0.2s ease;
            cursor: default;
        }
        .concept-item:hover {
            transform: translateX(5px);
        }
        .reference-item {
            position: relative;
            padding-left: 20px;
        }
        .reference-item:before {
            content: &quot;•&quot;;
            position: absolute;
            left: 5px;
            color: #4299e1;
        }
        .citation {
            font-style: italic;
            font-size: 0.9rem;
            color: #4a5568;
        }
        .keyword {
            display: inline-block;
            background-color: #ebf8ff;
            border-radius: 4px;
            padding: 2px 8px;
            margin: 2px;
            font-weight: 600;
            color: #2b6cb0;
        }
        .highlight-box {
            border-left: 4px solid #3182ce;
            background-color: #ebf8ff;
            padding: 8px 12px;
            margin-bottom: 12px;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in-section {
            animation: fadeIn 0.8s ease-out forwards;
        }
        .fade-in-1 { animation-delay: 0.3s; opacity: 0; }
        .fade-in-2 { animation-delay: 0.6s; opacity: 0; }
        .fade-in-3 { animation-delay: 0.9s; opacity: 0; }
        .fade-in-4 { animation-delay: 1.2s; opacity: 0; }
    </style>
</head>
<body>
    <div class=&quot;slide flex flex-col p-10&quot;>
        <h1 class=&quot;title text-4xl mb-4 text-center&quot;>Conclusiones y Referencias</h1>
        <div class=&quot;w-20 h-1 bg-blue-600 rounded-full mb-6 mx-auto&quot;></div>
        
        <!-- Main grid layout with 3 columns -->
        <div class=&quot;grid grid-cols-3 gap-6 mb-6 h-96&quot;>
            <!-- Left column - Key concepts -->
            <div class=&quot;content-box p-5 fade-in-section fade-in-1&quot;>
                <div class=&quot;flex items-center mb-4&quot;>
                    <i class=&quot;fas fa-lightbulb text-yellow-500 text-2xl mr-3&quot;></i>
                    <h2 class=&quot;text-xl text-blue-700&quot;>Conceptos Principales</h2>
                </div>
                
                <ul class=&quot;space-y-3 mt-4&quot;>
                    <li class=&quot;concept-item flex items-start&quot;>
                        <i class=&quot;fas fa-check-circle text-green-500 mt-1 mr-2&quot;></i>
                        <div>
                            <span class=&quot;font-semibold&quot;>Kernel Gaussiano:</span>
                            <span class=&quot;text-sm text-gray-600&quot;>Pesos basados en distribución normal 2D</span>
                        </div>
                    </li>
                    
                    <li class=&quot;concept-item flex items-start&quot;>
                        <i class=&quot;fas fa-check-circle text-green-500 mt-1 mr-2&quot;></i>
                        <div>
                            <span class=&quot;font-semibold&quot;>Tamaño y σ:</span>
                            <span class=&quot;text-sm text-gray-600&quot;>Determinan grado de suavizado y selectividad espacial</span>
                        </div>
                    </li>
                    
                    <li class=&quot;concept-item flex items-start&quot;>
                        <i class=&quot;fas fa-check-circle text-green-500 mt-1 mr-2&quot;></i>
                        <div>
                            <span class=&quot;font-semibold&quot;>Separabilidad:</span>
                            <span class=&quot;text-sm text-gray-600&quot;>Permite descomponer en 1D×1D para eficiencia O(2N)</span>
                        </div>
                    </li>
                    
                    <li class=&quot;concept-item flex items-start&quot;>
                        <i class=&quot;fas fa-check-circle text-green-500 mt-1 mr-2&quot;></i>
                        <div>
                            <span class=&quot;font-semibold&quot;>Padding:</span>
                            <span class=&quot;text-sm text-gray-600&quot;>Mirror o replicate para evitar bordes oscuros</span>
                        </div>
                    </li>
                    
                    <li class=&quot;concept-item flex items-start&quot;>
                        <i class=&quot;fas fa-check-circle text-green-500 mt-1 mr-2&quot;></i>
                        <div>
                            <span class=&quot;font-semibold&quot;>Relación imagen-kernel:</span>
                            <span class=&quot;text-sm text-gray-600&quot;>Escalar kernel con tamaño de imagen</span>
                        </div>
                    </li>
                </ul>
            </div>
            
            <!-- Middle column - Applications -->
            <div class=&quot;content-box p-5 fade-in-section fade-in-2&quot;>
                <div class=&quot;flex items-center mb-4&quot;>
                    <i class=&quot;fas fa-cogs text-blue-500 text-2xl mr-3&quot;></i>
                    <h2 class=&quot;text-xl text-blue-700&quot;>Aplicaciones Prácticas</h2>
                </div>
                
                <div class=&quot;space-y-4 mt-4&quot;>
                    <div class=&quot;highlight-box&quot;>
                        <div class=&quot;font-semibold text-blue-800 mb-1&quot;>Extracción de Regiones</div>
                        <div class=&quot;flex items-center&quot;>
                            <div class=&quot;flex-1&quot;>
                                <div class=&quot;key-point text-sm&quot;>Suavizado + umbralización</div>
                                <div class=&quot;key-point text-sm&quot;>Elimina detalles irrelevantes</div>
                            </div>
                            <i class=&quot;fas fa-object-group text-blue-400 text-3xl&quot;></i>
                        </div>
                    </div>
                    
                    <div class=&quot;highlight-box&quot;>
                        <div class=&quot;font-semibold text-blue-800 mb-1&quot;>Corrección de Sombreado</div>
                        <div class=&quot;flex items-center&quot;>
                            <div class=&quot;flex-1&quot;>
                                <div class=&quot;key-point text-sm&quot;>Estima patrón de iluminación</div>
                                <div class=&quot;key-point text-sm&quot;>g(x,y) = f(x,y) / s(x,y)</div>
                            </div>
                            <i class=&quot;fas fa-sun text-yellow-400 text-3xl&quot;></i>
                        </div>
                    </div>
                    
                    <div class=&quot;highlight-box&quot;>
                        <div class=&quot;font-semibold text-blue-800 mb-1&quot;>Reducción de Ruido</div>
                        <div class=&quot;flex items-center&quot;>
                            <div class=&quot;flex-1&quot;>
                                <div class=&quot;key-point text-sm&quot;>Preserva bordes mejor que box</div>
                                <div class=&quot;key-point text-sm&quot;>Compromiso detalle-suavizado</div>
                            </div>
                            <i class=&quot;fas fa-snowflake text-blue-300 text-3xl&quot;></i>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right column - Chart and design considerations -->
            <div class=&quot;content-box p-5 fade-in-section fade-in-3&quot;>
                <div class=&quot;flex items-center mb-4&quot;>
                    <i class=&quot;fas fa-chart-line text-purple-500 text-2xl mr-3&quot;></i>
                    <h2 class=&quot;text-xl text-blue-700&quot;>Comparativa Visual</h2>
                </div>
                
                <div class=&quot;h-60 mb-4&quot;>
                    <canvas id=&quot;filterComparisonChart&quot;></canvas>
                </div>
                
                <div class=&quot;grid grid-cols-2 gap-2 mt-2&quot;>
                    <div class=&quot;bg-gray-50 p-2 rounded text-center&quot;>
                        <div class=&quot;text-xs font-semibold text-gray-700&quot;>Box Filter</div>
                        <div class=&quot;text-xs text-gray-600&quot;>Transición abrupta</div>
                    </div>
                    <div class=&quot;bg-blue-50 p-2 rounded text-center&quot;>
                        <div class=&quot;text-xs font-semibold text-blue-700&quot;>Gaussian Filter</div>
                        <div class=&quot;text-xs text-blue-600&quot;>Transición suave</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Bottom section - Takeaways and References in two columns -->
        <div class=&quot;grid grid-cols-2 gap-6 fade-in-section fade-in-4&quot;>
            <!-- Left - Key takeaways -->
            <div class=&quot;content-box p-5&quot;>
                <div class=&quot;flex items-center mb-3&quot;>
                    <i class=&quot;fas fa-star text-yellow-500 text-xl mr-2&quot;></i>
                    <h2 class=&quot;text-lg text-blue-700&quot;>Conclusiones Clave</h2>
                </div>
                
                <div class=&quot;flex flex-wrap mt-3&quot;>
                    <span class=&quot;keyword&quot;>Filtro gaussiano = bordes más suaves</span>
                    <span class=&quot;keyword&quot;>Reducción de ruido eficiente</span>
                    <span class=&quot;keyword&quot;>Optimización con kernels separables</span>
                    <span class=&quot;keyword&quot;>Esencial para preprocesamiento</span>
                    <span class=&quot;keyword&quot;>Balance parámetros-resultados</span>
                    <span class=&quot;keyword&quot;>Impacto del método de padding</span>
                    <span class=&quot;keyword&quot;>Escalado proporcional</span>
                </div>
                
                <div class=&quot;text-center mt-4&quot;>
                    <p class=&quot;text-gray-600 italic&quot;>&quot;Entender la relación entre los parámetros del filtro y el tamaño de la imagen es fundamental para un procesamiento efectivo.&quot;</p>
                </div>
            </div>
            
            <!-- Right - References -->
            <div class=&quot;content-box p-5&quot;>
                <div class=&quot;flex items-center mb-3&quot;>
                    <i class=&quot;fas fa-book text-blue-800 text-xl mr-2&quot;></i>
                    <h2 class=&quot;text-lg text-blue-700&quot;>Referencias</h2>
                </div>
                
                <ul class=&quot;space-y-2 mt-3&quot;>
                    <li class=&quot;reference-item&quot;>
                        <span class=&quot;citation&quot;>González, R. C., & Woods, R. E. (2018). Digital Image Processing (4th ed.). Pearson.</span>
                    </li>
                    <li class=&quot;reference-item&quot;>
                        <span class=&quot;citation&quot;>Szeliski, R. (2022). Computer Vision: Algorithms and Applications (2nd ed.). Springer.</span>
                    </li>
                    <li class=&quot;reference-item&quot;>
                        <span class=&quot;citation&quot;>Burger, W., & Burge, M. J. (2016). Digital Image Processing: An Algorithmic Introduction Using Java. Springer.</span>
                    </li>
                    <li class=&quot;reference-item&quot;>
                        <span class=&quot;citation&quot;>Nixon, M., & Aguado, A. (2019). Feature Extraction and Image Processing for Computer Vision. Academic Press.</span>
                    </li>
                </ul>
                
                <div class=&quot;mt-3 text-right&quot;>
                    <span class=&quot;text-sm text-gray-500&quot;>© 2023 Procesamiento Digital de Imágenes</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        window.onload = function() {
            // Create comparison chart
            const ctx = document.getElementById('filterComparisonChart').getContext('2d');
            
            // Data representing edge response for box vs gaussian filter
            const labels = Array.from({length: 50}, (_, i) => i);
            
            // Box filter response (sharp transition)
            const boxResponse = labels.map(x => {
                if (x < 20) return 0;
                if (x >= 20 && x <= 30) return (x - 20) / 10;
                return 1;
            });
            
            // Gaussian filter response (smooth transition)
            const gaussianResponse = labels.map(x => {
                const center = 25;
                const sigma = 5;
                return 1 / (1 + Math.exp(-(x - center) / (sigma/2)));
            });
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Box Filter',
                            data: boxResponse,
                            borderColor: 'rgb(107, 114, 128)',
                            backgroundColor: 'rgba(107, 114, 128, 0.2)',
                            borderWidth: 2,
                            tension: 0.1,
                            fill: true
                        },
                        {
                            label: 'Gaussian Filter',
                            data: gaussianResponse,
                            borderColor: 'rgb(59, 130, 246)',
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 1.1,
                            title: {
                                display: true,
                                text: 'Intensidad'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Posición'
                            },
                            ticks: {
                                callback: function(value, index) {
                                    // Show fewer x-axis labels
                                    return index % 10 === 0 ? value : '';
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            align: 'center',
                            labels: {
                                boxWidth: 15,
                                usePointStyle: true
                            }
                        },
                        title: {
                            display: true,
                            text: 'Respuesta a Bordes',
                            font: {
                                size: 14
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
            
            // Add interactive hover effects to concepts
            const concepts = document.querySelectorAll('.concept-item');
            concepts.forEach(item => {
                item.addEventListener('mouseenter', function() {
                    this.classList.add('text-blue-700');
                });
                
                item.addEventListener('mouseleave', function() {
                    this.classList.remove('text-blue-700');
                });
            });
        };
    </script>
</body>
</html>" style="width:100%; height:100%; border:none;" sandbox="allow-scripts allow-same-origin allow-popups allow-forms allow-presentation"></iframe>
                    </section>
            </div>
        </div>
        
        <button class="nav-button prev-button" title="Previous Slide">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5 8.25 12l7.5-7.5" /></svg>
        </button>
        <button class="nav-button next-button" title="Next Slide">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m8.25 4.5 7.5 7.5-7.5 7.5" /></svg>
        </button>

        <script>
          let currentSlideIdx = 0;
          const slideElements = document.querySelectorAll('.presentation-slide');
          const totalExportedSlides = slideElements.length;
          const prevButton = document.querySelector('.prev-button');
          const nextButton = document.querySelector('.next-button');

          function showSlide(index) {
            if (index < 0 || index >= totalExportedSlides) return;
            slideElements.forEach((slideEl, i) => {
              slideEl.classList.toggle('active', i === index);
            });
            currentSlideIdx = index;
            updateNavButtons();
            // Update URL hash for potential deep linking (optional)
            // window.location.hash = slideElements[index] ? slideElements[index].id : '';
          }

          function navigateNext() {
            if (currentSlideIdx < totalExportedSlides - 1) {
              showSlide(currentSlideIdx + 1);
            }
          }

          function navigatePrev() {
            if (currentSlideIdx > 0) {
              showSlide(currentSlideIdx - 1);
            }
          }

          function updateNavButtons() {
            if (!prevButton || !nextButton) return;
            prevButton.disabled = currentSlideIdx === 0;
            nextButton.disabled = currentSlideIdx === totalExportedSlides - 1;
          }

          if (nextButton) nextButton.addEventListener('click', navigateNext);
          if (prevButton) prevButton.addEventListener('click', navigatePrev);

          document.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowRight' || event.key === 'PageDown' || event.key === ' ') {
              event.preventDefault(); // Prevent space bar from scrolling page if it were possible
              navigateNext();
            } else if (event.key === 'ArrowLeft' || event.key === 'PageUp') {
              event.preventDefault();
              navigatePrev();
            }
          });
          
          // Initial setup
          if (totalExportedSlides > 0) {
            showSlide(0);
          } else {
            if(prevButton) prevButton.style.display = 'none';
            if(nextButton) nextButton.style.display = 'none';
          }
        </script>
      </body>
      </html>
    